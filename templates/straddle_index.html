<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Straddle Chart Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: visible;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 300;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .form-section {
            padding: 20px;
            background: rgba(255, 255, 255, 0.02);
            overflow: visible;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
            overflow: visible;
        }

        .form-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            overflow: visible;
        }

        .form-group:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .form-group label {
            display: block;
            margin-bottom: 3px;
            font-weight: 600;
            color: #ffffff;
            font-size: 0.75rem;
        }

        .indicator-icon-container {
            position: relative;
            display: inline-block;
        }

        .indicator-icon-btn {
            background: linear-gradient(45deg, #00ccff, #0099cc);
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            color: #ffffff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 3px 10px rgba(0, 204, 255, 0.3);
        }

        .indicator-icon-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(0, 204, 255, 0.4);
        }

        .indicator-count {
            background: #ff4444;
            color: #ffffff;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            margin-left: 5px;
        }

        .indicator-dropdown {
            position: absolute;
            bottom: 100%;
            left: 0;
            background: rgba(26, 26, 46, 0.98);
            border: 2px solid rgba(0, 204, 255, 0.4);
            border-radius: 10px;
            padding: 12px;
            min-width: 320px;
            max-height: 450px;
            overflow-y: auto;
            z-index: 99999;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(15px);
            margin-bottom: 5px;
        }

        .indicator-menu-header {
            font-size: 0.9rem;
            font-weight: bold;
            color: #00ccff;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 204, 255, 0.3);
        }

        .indicator-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 5px;
        }

        .indicator-option:hover {
            background: rgba(0, 204, 255, 0.1);
        }

        .indicator-check {
            font-size: 1rem;
            color: #00ccff;
            min-width: 16px;
        }

        .indicator-name {
            font-weight: bold;
            color: #ffffff;
            font-size: 0.85rem;
            min-width: 50px;
        }

        .indicator-desc {
            color: #cccccc;
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .ema-submenu {
            margin-left: 20px;
            margin-top: 5px;
            padding-left: 10px;
            border-left: 2px solid rgba(0, 204, 255, 0.3);
        }

        .ema-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .ema-option:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .ema-option input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #667eea;
            cursor: pointer;
        }

        .ema-option label {
            margin: 0;
            font-weight: 400;
            font-size: 14px;
            cursor: pointer;
            color: #cccccc;
        }

        .form-group select,
        .form-group input {
            width: 100%;
            padding: 5px 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            color: #ffffff;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .form-group select:focus,
        .form-group input:focus {
            outline: none;
            border-color: #00ccff;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.3);
            background: rgba(255, 255, 255, 0.08);
        }

        .form-group select:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .form-group select option {
            background: #1a1a2e;
            color: #ffffff;
            padding: 10px;
        }

        .form-text {
            margin-top: 5px;
            font-size: 0.85rem;
            opacity: 0.8;
            transition: all 0.3s ease;
            display: block;
        }
        
        .form-text:hover {
            opacity: 1;
        }
        
        .timeframe-display {
            margin-top: 8px;
            text-align: center;
        }
        
        .timeframe-badge {
            display: inline-block;
            padding: 6px 12px;
            background: linear-gradient(45deg, #00ff88, #00cc66);
            color: #1a1a2e;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }

        /* MACD Panel Styling */
        .macd-panel {
            background: #0a0a0a;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 5px;
            margin-top: 10px;
            width: 100%;
            position: relative;
            z-index: 4;
        }

        .macd-panel h3 {
            color: #ffffff;
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 5px 0;
            text-align: center;
        }

        /* RSI Panel Styling */
        .rsi-panel {
            background: #0a0a0a;
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            width: 100%;
            position: relative;
            z-index: 4;
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.1);
        }

        .rsi-panel h3 {
            color: #00ff88;
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 15px 0;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .date-info {
            margin-top: 15px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .date-info p {
            margin: 5px 0;
            font-size: 14px;
            color: #b0b0b0;
        }

        /* Date Selector Styles */
        .date-selector-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
            overflow: hidden;
        }

        .date-info-section {
            margin: 10px 0 15px 0;
        }

        .date-range-info {
            display: block;
            text-align: left;
            padding: 10px 15px;
            background: rgba(0, 255, 136, 0.15);
            border: 2px solid rgba(0, 255, 136, 0.4);
            border-radius: 8px;
            color: #00ff88;
            font-weight: 500;
            font-size: 0.9rem;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.2);
            backdrop-filter: blur(10px);
            width: 100%;
            box-sizing: border-box;
        }

        .date-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
            width: 100%;
        }

        .date-inputs select {
            padding: 6px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
            color: #ffffff;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .date-inputs select:focus {
            outline: none;
            border-color: #00ccff;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.3);
        }

        .date-inputs select option {
            background: #1a1a2e;
            color: #ffffff;
            padding: 8px;
        }

        .date-navigation {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .nav-btn {
            background: linear-gradient(45deg, #00ccff, #0099cc);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 204, 255, 0.3);
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 204, 255, 0.4);
            background: linear-gradient(45deg, #0099cc, #00ccff);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }



        .generate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 18px 40px;
            font-size: 18px;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 0 auto;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            position: relative;
            z-index: 1;
        }

        .generate-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.4);
        }

        .generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .chart-section {
            padding: 40px;
            display: none;
            margin-bottom: 30px;
            position: relative;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 15px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-title {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.8rem;
            font-weight: 600;
            color: #e0e0e0;
        }

        .chart-image {
            width: 100%;
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .interactive-chart-container {
            width: 100%;
            height: 500px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .interactive-chart-container canvas {
            border-radius: 8px;
        }

        .candlestick-chart-container {
            width: 100%;
            min-height: 450px;
            max-height: 500px;
            background: #0a0a0a;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0 30px 0;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            z-index: 5;
        }
        
        /* Professional OHLC Tooltip Styling */
        .ohlc-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            border: 2px solid #00ccff;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            min-width: 180px;
            backdrop-filter: blur(10px);
        }
        
        .tooltip-header {
            border-bottom: 1px solid #444444;
            padding-bottom: 8px;
            margin-bottom: 8px;
            font-weight: bold;
            color: #00ccff;
        }
        
        .tooltip-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .tooltip-label {
            color: #cccccc;
            font-weight: 500;
        }
        
        .tooltip-value {
            color: #ffffff;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        


        .chart-type-toggle {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .chart-type-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: auto;
            user-select: none;
        }

        .chart-type-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.1);
        }

        .chart-type-btn:active {
            transform: translateY(0px);
            box-shadow: 0 2px 8px rgba(255, 255, 255, 0.2);
        }

        .chart-type-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .chart-type-btn.active:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .chart-info {
            margin-top: 30px;
            margin-bottom: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            position: relative;
            z-index: 10;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .info-card h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .info-card p {
            color: #e0e0e0;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            color: #ff6b6b;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            display: none;
        }

        .success-message {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
            color: #51cf66;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            display: none;
        }

        @media (max-width: 768px) {
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .form-section,
            .chart-section {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="/" class="back-button">← Back to Main</a>
            <h1>🎯 Straddle Chart Analysis</h1>
            <p>Analyze option straddle strategies with real-time data visualization</p>
        </div>

        <!-- Date Range Information Section -->
        <div class="date-info-section">
            <div class="date-range-info" id="dateRangeInfo">
                <small>Loading date range...</small>
            </div>
        </div>

        <div class="form-section">
            <form id="straddleForm">
                <div class="form-grid">
                    <div class="form-group">
                        <label for="symbol">Select Symbol</label>
                        <select id="symbol" name="symbol" required>
                            <option value="nifty">NIFTY</option>
                            <option value="banknifty">BANKNIFTY</option>
                            <option value="midcpnifty">MIDCPNIFTY</option>
                            <option value="sensex">SENSEX</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="dateSelect">Select Date</label>
                        <div class="date-selector-container">
                            <div class="date-inputs">
                                <select id="yearSelect" onchange="updateDateOptions(); updateDebugDisplay();">
                                    <option value="">Year</option>
                                </select>
                                <select id="monthSelect" onchange="onMonthChange()">
                                    <option value="">Month</option>
                                </select>
                                <select id="daySelect" onchange="onDateChange(); updateDebugDisplay();">
                                    <option value="">Day</option>
                                </select>
                            </div>
                            <div class="date-navigation">
                                <button type="button" class="nav-btn" onclick="navigateDate(-1)" title="Previous Date">◀</button>
                                <button type="button" class="nav-btn" onclick="navigateDate(1)" title="Next Date">▶</button>
                            </div>
                            <div class="date-debug" id="dateDebug" style="margin-top: 10px; text-align: center; font-size: 12px; color: #00ccff;">
                                <small>Debug: Year: <span id="debugYear">-</span> | Month: <span id="debugMonth">-</span> | Day: <span id="debugDay">-</span></small>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="callStrike">Call Strike Price</label>
                        <select id="callStrike" name="callStrike" required disabled>
                            <option value="">Select Date First</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="putStrike">Put Strike Price</label>
                        <select id="putStrike" name="putStrike" required disabled>
                            <option value="">Select Date First</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="expiry">Expiry Date</label>
                        <select id="expiry" name="expiry" required disabled>
                            <option value="">Select Strikes First</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="timeframe">Time Interval (minutes)</label>
                        <input type="number" id="timeframe" name="timeframe" value="1" min="1" max="60" step="1">
                        <small class="form-text" id="timeframeInfo">Select time interval for candlestick formation</small>
                        <div class="timeframe-display" id="timeframeDisplay" style="display: none;">
                            <span class="timeframe-badge">Selected: <strong id="selectedTimeframe">1</strong> min</span>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="indicators">Technical Indicators</label>
                        <div class="indicator-icon-container">
                            <button type="button" class="indicator-icon-btn" onclick="toggleIndicatorMenu()" title="Select Technical Indicators">
                                📊
                                <span class="indicator-count" id="indicatorCount">0</span>
                            </button>
                            <div class="indicator-dropdown" id="indicatorDropdown" style="display: none;">
                                <div class="indicator-menu-header">Select Indicators</div>
                                <div class="indicator-option" onclick="toggleIndicator('vwap')">
                                    <span class="indicator-check" id="check_vwap">☐</span>
                                    <span class="indicator-name">VWAP</span>
                                    <span class="indicator-desc">Volume Weighted Average Price</span>
                                </div>
                                <div class="indicator-option" onclick="toggleIndicator('macd')">
                                    <span class="indicator-check" id="check_macd">☐</span>
                                    <span class="indicator-name">MACD</span>
                                    <span class="indicator-desc">Moving Average Convergence Divergence</span>
                                </div>
                                <div class="indicator-option" onclick="toggleIndicator('rsi')">
                                    <span class="indicator-check" id="check_rsi">☐</span>
                                    <span class="indicator-name">RSI</span>
                                    <span class="indicator-desc">Relative Strength Index</span>
                                </div>
                                <div class="indicator-option" onclick="toggleIndicator('ema')">
                                    <span class="indicator-check" id="check_ema">☐</span>
                                    <span class="indicator-name">EMA</span>
                                    <span class="indicator-desc">Exponential Moving Average</span>
                                </div>
                                <div class="ema-submenu" id="emaSubmenu" style="display: none;">
                                    <div class="ema-option" onclick="toggleEMAOption('ema_20')">
                                        <span class="indicator-check" id="check_ema_20">☐</span>
                                        <span>EMA 20</span>
                                    </div>
                                    <div class="ema-option" onclick="toggleEMAOption('ema_50')">
                                        <span class="indicator-check" id="check_ema_50">☐</span>
                                        <span>EMA 50</span>
                                    </div>
                                    <div class="ema-option" onclick="toggleEMAOption('ema_100')">
                                        <span class="indicator-check" id="check_ema_100">☐</span>
                                        <span>EMA 100</span>
                                    </div>
                                    <div class="ema-option" onclick="toggleEMAOption('ema_200')">
                                        <span class="indicator-check" id="check_ema_200">☐</span>
                                        <span>EMA 200</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <small class="form-text">Click the icon to select indicators</small>
                    </div>
                </div>

                <button type="submit" class="generate-btn" id="generateBtn" disabled>
                    Generate Straddle Chart
                </button>
            </form>

            <div class="error-message" id="errorMessage"></div>
            <div class="success-message" id="successMessage"></div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Generating straddle chart...</p>
        </div>

        <div class="chart-section" id="chartSection">
            <div class="chart-container">
                <h2 class="chart-title" id="chartTitle"></h2>
                
                <!-- Chart Type Toggle Buttons -->
                <div class="chart-type-toggle" style="display: none;">
                    <button id="lineChartBtn" class="chart-type-btn active">
                        📈 Line Chart
                    </button>
                    <button id="candlestickChartBtn" class="chart-type-btn">
                        🕯️ Candlestick Chart
                    </button>
                </div>

                <!-- Interactive Chart Container -->
                <div class="interactive-chart-container">
                    <canvas id="interactiveChart" width="800" height="400"></canvas>
                </div>
                
                <!-- Professional Candlestick Chart Container -->
                <div class="candlestick-chart-container" style="display: none;">
                    <div id="candlestickChart" style="width: 100%; height: 400px; position: relative; margin-bottom: 20px;"></div>
                    
                    <!-- Professional OHLC Tooltip -->
                    <div id="ohlcTooltip" class="ohlc-tooltip">
                        <div class="tooltip-header">
                            <span id="tooltipTime">Time</span>
                        </div>
                        <div class="tooltip-content">
                            <div class="tooltip-row">
                                <span class="tooltip-label">Open:</span>
                                <span id="tooltipOpen" class="tooltip-value">0.00</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">High:</span>
                                <span id="tooltipHigh" class="tooltip-value">0.00</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Low:</span>
                                <span id="tooltipLow" class="tooltip-value">0.00</span>
                                </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Close:</span>
                                <span id="tooltipClose" class="tooltip-value">0.00</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">VWAP:</span>
                                <span id="tooltipVWAP" class="tooltip-value">0.00</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">MACD:</span>
                                <span id="tooltipMACD" class="tooltip-value">0.00</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Signal:</span>
                                <span id="tooltipSignal" class="tooltip-value">0.00</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Histogram:</span>
                                <span id="tooltipHistogram" class="tooltip-value">0.00</span>
                            </div>
                            <div class="tooltip-row" id="rsiRow" style="display: none;">
                                <span class="tooltip-label">RSI:</span>
                                <span id="tooltipRSI" class="tooltip-value">0.00</span>
                            </div>
                            <div class="tooltip-row" id="ema20Row" style="display: none;">
                                <span class="tooltip-label">EMA 20:</span>
                                <span id="tooltipEMA20" class="tooltip-value">0.00</span>
                            </div>
                            <div class="tooltip-row" id="ema50Row" style="display: none;">
                                <span class="tooltip-label">EMA 50:</span>
                                <span id="tooltipEMA50" class="tooltip-value">0.00</span>
                            </div>
                            <div class="tooltip-row" id="ema100Row" style="display: none;">
                                <span class="tooltip-label">EMA 100:</span>
                                <span id="tooltipEMA100" class="tooltip-value">0.00</span>
                            </div>
                            <div class="tooltip-row" id="ema200Row" style="display: none;">
                                <span class="tooltip-label">EMA 200:</span>
                                <span id="tooltipEMA200" class="tooltip-value">0.00</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- MACD Indicator Panel - Separate Container -->
                <div id="macdPanel" class="macd-panel" style="display: none;">
                    <div id="macdChart" style="width: 100%; height: 200px; position: relative; margin-bottom: 5px;"></div>
                </div>
                
                <!-- RSI Indicator Panel - Separate Container -->
                <div id="rsiPanel" class="rsi-panel" style="display: none;">
                    <div id="rsiChart" style="width: 100%; height: 200px; position: relative; margin-bottom: 20px;"></div>
                </div>
                
                <!-- Static Chart Image (fallback) -->
                <img id="chartImage" class="chart-image" alt="Straddle Chart" style="display: none;">
                
                <div class="chart-info" id="chartInfo">
                    <!-- Chart information will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Chart.js Library -->
    <!-- TradingView LightweightCharts Library -->
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    
    <!-- Fallback if CDN fails -->
    <script>
        console.log('=== CHECKING LIGHTWEIGHT CHARTS LIBRARY ===');
        console.log('LightweightCharts available:', typeof LightweightCharts !== 'undefined');
        if (typeof LightweightCharts !== 'undefined') {
            console.log('LightweightCharts version:', LightweightCharts.version || 'unknown');
            console.log('LightweightCharts methods:', Object.getOwnPropertyNames(LightweightCharts));
        } else {
            console.log('LightweightCharts CDN failed, trying alternative...');
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js';
            script.onload = function() {
                console.log('LightweightCharts loaded from alternative source');
                console.log('LightweightCharts version:', LightweightCharts.version || 'unknown');
                console.log('LightweightCharts methods:', Object.getOwnPropertyNames(LightweightCharts));
            };
            script.onerror = function() {
                console.error('Failed to load LightweightCharts from all sources');
            };
            document.head.appendChild(script);
        }
    </script>
    
    <!-- Chart.js as fallback -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
    


    <script>
        // Function to toggle EMA dropdown
        function toggleEMADropdown() {
            const emaCheckbox = document.getElementById('ema');
            const emaDropdown = document.getElementById('emaDropdown');
            
            if (emaCheckbox.checked) {
                emaDropdown.style.display = 'block';
            } else {
                emaDropdown.style.display = 'none';
                // Uncheck all EMA period checkboxes when main EMA is unchecked
                const emaPeriods = document.querySelectorAll('input[name="ema_periods"]');
                emaPeriods.forEach(checkbox => {
                    checkbox.checked = false;
                });
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const form = document.getElementById('straddleForm');
            const symbolSelect = document.getElementById('symbol');
            const callStrikeSelect = document.getElementById('callStrike');
            const putStrikeSelect = document.getElementById('putStrike');
            const expirySelect = document.getElementById('expiry');
            const generateBtn = document.getElementById('generateBtn');
            const loading = document.getElementById('loading');
            const chartSection = document.getElementById('chartSection');
            const errorMessage = document.getElementById('errorMessage');
            const successMessage = document.getElementById('successMessage');
            
            // Chart.js instance
            let interactiveChart = null;
            let currentChartData = null;
            let currentChartTitle = null;

            // Date selection variables
            let availableDates = [];
            let currentDateIndex = 0;
            let symbol = 'nifty'; // Default symbol for straddle

            // Initialize date selector
            initializeDateSelector();

            // Add missing functions to fix errors
            window.updateDateOptions = function() {
                try {
                    const yearSelect = document.getElementById('yearSelect');
                    const monthSelect = document.getElementById('monthSelect');
                    const daySelect = document.getElementById('daySelect');
                    
                    const selectedYear = yearSelect.value;
                    const selectedMonth = monthSelect.value;
                    
                    console.log('updateDateOptions called with:', { selectedYear, selectedMonth });
                    
                    // Only clear month and day selectors if year changed
                    if (yearSelect.dataset.lastYear !== selectedYear) {
                        monthSelect.innerHTML = '<option value="">Month</option>';
                        daySelect.innerHTML = '<option value="">Day</option>';
                        
                        // Populate month selector
                        for (let month = 1; month <= 12; month++) {
                            const option = document.createElement('option');
                            option.value = month.toString().padStart(2, '0');
                            option.textContent = new Date(selectedYear, month - 1, 1).toLocaleDateString('en-US', { month: 'long' });
                            monthSelect.appendChild(option);
                        }
                        
                        // Store the year we just processed
                        yearSelect.dataset.lastYear = selectedYear;
                    }
                    
                    // Only populate day selector if month is selected and year hasn't changed
                    if (selectedMonth && selectedYear) {
                        // Check if day selector is already populated
                        if (daySelect.children.length <= 1) {
                            // Filter available days from database for this year-month
                            const yearMonth = `${selectedYear}-${selectedMonth}`;
                            const availableDays = availableDates
                                .filter(date => date.startsWith(yearMonth))
                                .map(date => date.substring(8, 10))
                                .sort((a, b) => parseInt(a) - parseInt(b));
                            
                            // Show all days in month but only enable available ones
                            const daysInMonth = new Date(selectedYear, parseInt(selectedMonth), 0).getDate();
                            for (let day = 1; day <= daysInMonth; day++) {
                                const dayStr = day.toString().padStart(2, '0');
                                const option = document.createElement('option');
                                option.value = dayStr;
                                
                                // Check if this day is available in database
                                const isAvailable = availableDays.includes(dayStr);
                                
                                // Check if this is a weekend
                                const date = new Date(selectedYear, parseInt(selectedMonth) - 1, day);
                                const dayOfWeek = date.getDay(); // 0 = Sunday, 6 = Saturday
                                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                                
                                if (isWeekend) {
                                    option.textContent = `${day} (Weekend)`;
                                    option.disabled = true;
                                    option.style.color = '#ff8888';
                                    option.style.fontStyle = 'italic';
                                } else if (!isAvailable) {
                                    option.textContent = `${day} (Holiday)`;
                                    option.disabled = true;
                                    option.style.color = '#666';
                                    option.style.fontStyle = 'italic';
                                } else {
                                    option.textContent = day;
                                }
                                
                                daySelect.appendChild(option);
                            }
                        }
                    }
                    
                    // Update debug display
                    if (window.updateDebugDisplay) {
                        window.updateDebugDisplay();
                    }
                } catch (error) {
                    console.error('Error in updateDateOptions:', error);
                }
            };

            window.onMonthChange = function() {
                const selectedMonth = document.getElementById('monthSelect').value;
                const selectedYear = document.getElementById('yearSelect').value;
                console.log('Month changed:', selectedMonth);
                
                // Only populate day selector if month is selected
                if (selectedMonth && selectedYear) {
                    const daySelect = document.getElementById('daySelect');
                    daySelect.innerHTML = '<option value="">Day</option>';
                    
                    // Filter available days from database for this year-month (same as Options Chain)
                    const yearMonth = `${selectedYear}-${selectedMonth}`;
                    const availableDays = availableDates
                        .filter(date => date.startsWith(yearMonth))
                        .map(date => date.substring(8, 10))
                        .sort((a, b) => parseInt(a) - parseInt(b));
                    
                    const daysInMonth = new Date(selectedYear, parseInt(selectedMonth), 0).getDate();
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dayStr = day.toString().padStart(2, '0');
                        const option = document.createElement('option');
                        option.value = dayStr;
                        
                        // Check if this day is available in database
                        const isAvailable = availableDays.includes(dayStr);
                        
                        // Check if this is a weekend
                        const date = new Date(selectedYear, parseInt(selectedMonth) - 1, day);
                        const dayOfWeek = date.getDay(); // 0 = Sunday, 6 = Saturday
                        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                        
                        if (isWeekend) {
                            option.textContent = `${day} (Weekend)`;
                            option.disabled = true;
                            option.style.color = '#ff8888';
                            option.style.fontStyle = 'italic';
                        } else if (!isAvailable) {
                            option.textContent = `${day} (Holiday)`;
                            option.disabled = true;
                            option.style.color = '#666';
                            option.style.fontStyle = 'italic';
                        } else {
                            option.textContent = day;
                        }
                        
                        daySelect.appendChild(option);
                    }
                }
                
                if (window.updateDebugDisplay) {
                    window.updateDebugDisplay();
                }
            };

            window.updateDebugDisplay = function() {
                try {
                    const year = document.getElementById('yearSelect').value || '-';
                    const month = document.getElementById('monthSelect').value || '-';
                    const day = document.getElementById('daySelect').value || '-';
                    
                    const debugYear = document.getElementById('debugYear');
                    const debugMonth = document.getElementById('debugMonth');
                    const debugDay = document.getElementById('debugDay');
                    
                    if (debugYear) debugYear.textContent = year;
                    if (debugMonth) debugMonth.textContent = month;
                    if (debugDay) debugDay.textContent = day;
                    
                    console.log('Debug display updated:', { year, month, day });
                } catch (error) {
                    console.error('Error in updateDebugDisplay:', error);
                }
            };

            // Function to calculate actual weekend days
            function calculateActualWeekends(startDateStr, endDateStr) {
                try {
                    const startDate = new Date(startDateStr);
                    const endDate = new Date(endDateStr);
                    let weekendCount = 0;
                    let currentDate = new Date(startDate);
                    
                    while (currentDate <= endDate) {
                        // Saturday = 6, Sunday = 0
                        if (currentDate.getDay() === 0 || currentDate.getDay() === 6) {
                            weekendCount++;
                        }
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                    
                    return weekendCount;
                } catch (error) {
                    console.error('Error calculating actual weekends:', error);
                    return 0;
                }
            }

            // Override the updateDateRangeInfo function with correct calculation
            window.updateDateRangeInfo = function() {
                if (availableDates.length > 0) {
                    // Use the ACTUAL first and last dates from availableDates, not API date range
                    const actualMinDate = availableDates[0];  // First date from database
                    const actualMaxDate = availableDates[availableDates.length - 1];  // Last date from database
                    
                    // Calculate actual calendar days between min and max date
                    const startDate = new Date(actualMinDate);
                    const endDate = new Date(actualMaxDate);
                    const totalCalendarDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
                    
                    // Count actual trading days (available dates)
                    const actualTradingDays = availableDates.length;
                    
                    // Calculate actual weekends and holidays separately
                    const actualWeekends = calculateActualWeekends(actualMinDate, actualMaxDate);
                    const holidays = totalCalendarDays - actualTradingDays - actualWeekends;
                    
                    console.log('Straddle Date calculation:', {
                        actualMinDate,
                        actualMaxDate,
                        totalCalendarDays,
                        actualTradingDays,
                        actualWeekends,
                        holidays
                    });
                    
                    // Debug: Check for calculation issues with options data
                    if (holidays < 0) {
                        console.error('STRADDLE CALCULATION ERROR: Negative holidays!', {
                            actualMinDate,
                            actualMaxDate,
                            totalCalendarDays,
                            actualTradingDays,
                            actualWeekends,
                            calculatedHolidays: holidays
                        });
                    }
                    
                    const dateRangeInfo = document.getElementById('dateRangeInfo');
                    dateRangeInfo.innerHTML = `
                        <strong>Available Date Range:</strong> ${actualMinDate} to ${actualMaxDate} | 📅 <strong>Total Days:</strong> ${totalCalendarDays} | 📊 <strong>Trading Days:</strong> ${actualTradingDays} | 🏖️ <strong>Weekends:</strong> ${actualWeekends} | 🏛️ <strong>Holidays:</strong> ${holidays}
                    `;
                }
            };

            // Symbol change handler
            symbolSelect.addEventListener('change', function() {
                symbol = this.value;
                console.log('Symbol changed to:', symbol);
                // Clear existing selections when symbol changes
                callStrikeSelect.innerHTML = '<option value="">Select Call Strike</option>';
                putStrikeSelect.innerHTML = '<option value="">Select Put Strike</option>';
                expirySelect.innerHTML = '<option value="">Select Expiry</option>';
                // Reload dates for the new symbol
                initializeDateSelector();
            });

            // Call strike change handler
            callStrikeSelect.addEventListener('change', function() {
                if (this.value && putStrikeSelect.value) {
                    loadExpiries();
                }
            });

            // Put strike change handler
            putStrikeSelect.addEventListener('change', function() {
                if (this.value && callStrikeSelect.value) {
                    loadExpiries();
                }
            });

            // Form submission
            form.addEventListener('submit', function(e) {
                e.preventDefault();
                generateStraddleChart();
            });

            function initializeDateSelector() {
                // Get available dates for STRADDLE (intersection of call and put)
                fetch(`/get_straddle_dates?symbol=${symbol}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.dates && data.dates.length > 0) {
                            availableDates = data.dates.sort();
                            currentDateIndex = Math.floor(availableDates.length / 2);
                            
                            console.log('Straddle dates loaded:', {
                                totalDates: availableDates.length,
                                callDatesCount: data.call_dates_count,
                                putDatesCount: data.put_dates_count,
                                intersectionDatesCount: data.intersection_dates_count
                            });
                            
                            // Populate year selector
                            populateYearSelector();
                            
                            // Update date range info
                            updateDateRangeInfo();
                            
                            // Enable navigation buttons
                            updateNavigationButtons();
                            
                            // Set initial date (but don't auto-select)
                            setInitialDate();
                        } else {
                            showError('No dates available for the selected symbol');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching straddle dates:', error);
                        showError('Failed to load available straddle dates');
                    });
            }

            function populateYearSelector() {
                const yearSelect = document.getElementById('yearSelect');
                yearSelect.innerHTML = '<option value="">Year</option>';
                
                // Get unique years from available dates
                const years = [...new Set(availableDates.map(date => date.split('-')[0]))].sort();
                
                years.forEach(year => {
                    const option = document.createElement('option');
                    option.value = year;
                    option.textContent = year;
                    yearSelect.appendChild(option);
                });
            }

            function updateDateOptions() {
                const yearSelect = document.getElementById('yearSelect');
                const monthSelect = document.getElementById('monthSelect');
                const daySelect = document.getElementById('daySelect');
                
                const selectedYear = yearSelect.value;
                const selectedMonth = monthSelect.value;
                
                // Only clear month and day selectors if year changed
                if (yearSelect.dataset.lastYear !== selectedYear) {
                    monthSelect.innerHTML = '<option value="">Month</option>';
                    daySelect.innerHTML = '<option value="">Day</option>';
                    
                    // Populate month selector
                    for (let month = 1; month <= 12; month++) {
                        const option = document.createElement('option');
                        option.value = month.toString().padStart(2, '0');
                        option.textContent = new Date(selectedYear, month - 1, 1).toLocaleDateString('en-US', { month: 'long' });
                        monthSelect.appendChild(option);
                    }
                    
                    // Store the year we just processed
                    yearSelect.dataset.lastYear = selectedYear;
                }
                
                // Only populate day selector if month is selected and year hasn't changed
                if (selectedMonth && selectedYear) {
                    // Check if day selector is already populated
                    if (daySelect.children.length <= 1) {
                        // Filter available days from database for this year-month (same as Options Chain)
                        const yearMonth = `${selectedYear}-${selectedMonth}`;
                        const availableDays = availableDates
                            .filter(date => date.startsWith(yearMonth))
                            .map(date => date.substring(8, 10))
                            .sort((a, b) => parseInt(a) - parseInt(b));
                        
                        const daysInMonth = new Date(selectedYear, parseInt(selectedMonth), 0).getDate();
                        for (let day = 1; day <= daysInMonth; day++) {
                            const dayStr = day.toString().padStart(2, '0');
                            const option = document.createElement('option');
                            option.value = dayStr;
                            
                            // Check if this day is available in database
                            const isAvailable = availableDays.includes(dayStr);
                            
                            // Check if this is a weekend
                            const date = new Date(selectedYear, parseInt(selectedMonth) - 1, day);
                            const dayOfWeek = date.getDay(); // 0 = Sunday, 6 = Saturday
                            const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                            
                            if (isWeekend) {
                                option.textContent = `${day} (Weekend)`;
                                option.disabled = true;
                                option.style.color = '#ff8888';
                                option.style.fontStyle = 'italic';
                            } else if (!isAvailable) {
                                option.textContent = `${day} (Holiday)`;
                                option.disabled = true;
                                option.style.color = '#666';
                                option.style.fontStyle = 'italic';
                            } else {
                                option.textContent = day;
                            }
                            
                            daySelect.appendChild(option);
                        }
                    }
                }
                
                // Update debug display
                updateDebugDisplay();
            }

            function updateDateRangeInfo() {
                if (availableDates.length > 0) {
                    // Use the ACTUAL first and last dates from availableDates (same as single chart fix)
                    const actualMinDate = availableDates[0];
                    const actualMaxDate = availableDates[availableDates.length - 1];
                    
                    // Calculate total calendar days between min and max date
                    const minDateObj = new Date(actualMinDate);
                    const maxDateObj = new Date(actualMaxDate);
                    const totalCalendarDays = Math.ceil((maxDateObj - minDateObj) / (1000 * 60 * 60 * 24)) + 1;
                    
                    // Actual trading days from database
                    const actualTradingDays = availableDates.length;
                    
                    // Calculate actual weekends and holidays separately
                    const actualWeekends = calculateActualWeekends(actualMinDate, actualMaxDate);
                    const holidays = totalCalendarDays - actualTradingDays - actualWeekends;
                    
                    // Debug: Check for calculation issues
                    if (holidays < 0) {
                        console.error('STRADDLE UPDATE DATE RANGE ERROR: Negative holidays!', {
                            actualMinDate,
                            actualMaxDate,
                            totalCalendarDays,
                            actualTradingDays,
                            actualWeekends,
                            calculatedHolidays: holidays
                        });
                    }
                    
                    const dateRangeInfo = document.getElementById('dateRangeInfo');
                    dateRangeInfo.innerHTML = `
                        <strong>Available Date Range:</strong> ${actualMinDate} to ${actualMaxDate} | 📅 <strong>Total Days:</strong> ${totalCalendarDays} | 📊 <strong>Trading Days:</strong> ${actualTradingDays} | 🏖️ <strong>Weekends:</strong> ${actualWeekends} | 🏛️ <strong>Holidays:</strong> ${holidays}
                    `;
                }
            }

            function setInitialDate() {
                if (availableDates.length > 0) {
                    // Don't auto-select dates - let user choose manually
                    console.log('Initial date set - dropdowns will start empty');
                }
            }

            window.updateDebugDisplay = function() {
                const year = document.getElementById('yearSelect').value || '-';
                const month = document.getElementById('monthSelect').value || '-';
                const day = document.getElementById('daySelect').value || '-';
                
                document.getElementById('debugYear').textContent = year;
                document.getElementById('debugMonth').textContent = month;
                document.getElementById('debugDay').textContent = day;
            }

            function addDateEventListeners() {
                const yearSelect = document.getElementById('yearSelect');
                const monthSelect = document.getElementById('monthSelect');
                const daySelect = document.getElementById('daySelect');
                
                if (yearSelect) {
                    yearSelect.addEventListener('change', function() {
                        console.log('Year changed, calling updateDebugDisplay and onDateChange');
                        updateDebugDisplay();
                        onDateChange();
                    });
                }
                if (monthSelect) {
                    monthSelect.addEventListener('change', function() {
                        console.log('Month changed, calling updateDebugDisplay and onDateChange');
                        updateDebugDisplay();
                        onDateChange();
                    });
                }
                if (daySelect) {
                    daySelect.addEventListener('change', function() {
                        console.log('Day changed, calling updateDebugDisplay and onDateChange');
                        updateDebugDisplay();
                        onDateChange();
                    });
                }
            }

            function getSelectedDate() {
                const year = document.getElementById('yearSelect').value;
                const month = document.getElementById('monthSelect').value;
                const day = document.getElementById('daySelect').value;
                
                console.log('getSelectedDate - Year:', year, 'Month:', month, 'Day:', day);
                
                if (year && month && day) {
                    const dateString = `${year}-${month}-${day}`;
                    console.log('getSelectedDate returning:', dateString);
                    return dateString;
                }
                console.log('getSelectedDate returning null - missing values');
                return null;
            }

            window.onDateChange = function() {
                console.log('onDateChange function called');
                const date = getSelectedDate();
                console.log('getSelectedDate returned:', date);
                if (date) {
                    console.log('Date is valid, calling loadStrikes with:', date);
                    loadStrikes(date);
                    resetStrikesAndExpiry();
                } else {
                    console.log('Date is invalid or null');
                }
            }

            window.navigateDate = function(direction) {
                if (availableDates.length === 0) return;
                
                let targetDate;
                if (direction > 0) {
                    // Next date
                    currentDateIndex++;
                    if (currentDateIndex >= availableDates.length) {
                        currentDateIndex = availableDates.length - 1;
                        return;
                    }
                    targetDate = availableDates[currentDateIndex];
                } else {
                    // Previous date
                    currentDateIndex--;
                    if (currentDateIndex < 0) {
                        currentDateIndex = 0;
                        return;
                    }
                    targetDate = availableDates[currentDateIndex];
                }
                
                // Check if target date is a weekend
                let targetDateObj = new Date(targetDate);
                if (isWeekend(targetDateObj)) {
                    // Find the next/previous trading day
                    if (direction > 0) {
                        targetDateObj = findNextTradingDay(targetDateObj);
                    } else {
                        targetDateObj = findPreviousTradingDay(targetDateObj);
                    }
                    
                    // Update targetDate to the trading day
                    targetDate = targetDateObj.toISOString().split('T')[0];
                    
                    // Find the index of this trading day in availableDates
                    const newIndex = availableDates.indexOf(targetDate);
                    if (newIndex !== -1) {
                        currentDateIndex = newIndex;
                    }
                }
                
                const dateParts = targetDate.split('-');
                
                // Update selectors without triggering updateDateOptions multiple times
                const yearSelect = document.getElementById('yearSelect');
                const monthSelect = document.getElementById('monthSelect');
                const daySelect = document.getElementById('daySelect');
                
                // Set year first
                yearSelect.value = dateParts[0];
                // Clear the lastYear dataset to force month repopulation
                delete yearSelect.dataset.lastYear;
                updateDateOptions();
                
                // Set month and day
                monthSelect.value = dateParts[1];
                daySelect.value = dateParts[2];
                
                // Trigger date change
                onDateChange();
                
                // Update navigation buttons
                updateNavigationButtons();
            }

            function updateNavigationButtons() {
                const prevBtn = document.querySelector('.nav-btn[onclick="navigateDate(-1)"]');
                const nextBtn = document.querySelector('.nav-btn[onclick="navigateDate(1)"]');
                
                if (prevBtn) prevBtn.disabled = currentDateIndex <= 0;
                if (nextBtn) nextBtn.disabled = currentDateIndex >= availableDates.length - 1;
            }

            function findNextTradingDay(date) {
                let nextDay = new Date(date);
                nextDay.setDate(nextDay.getDate() + 1);
                
                // Keep moving forward until we find a weekday
                while (nextDay.getDay() === 0 || nextDay.getDay() === 6) {
                    nextDay.setDate(nextDay.getDate() + 1);
                }
                
                return nextDay;
            }

            function findPreviousTradingDay(date) {
                let prevDay = new Date(date);
                prevDay.setDate(prevDay.getDate() - 1);
                
                // Keep moving backward until we find a weekday
                while (prevDay.getDay() === 0 || prevDay.getDay() === 6) {
                    prevDay.setDate(prevDay.getDate() - 1);
                }
                
                return prevDay;
            }

            function isWeekend(date) {
                const dayOfWeek = date.getDay();
                return dayOfWeek === 0 || dayOfWeek === 6;
            }

            function loadStrikes(date) {
                const symbol = symbolSelect.value;
                
                console.log('loadStrikes called with date:', date, 'symbol:', symbol);
                
                fetch(`/get_straddle_strikes?date=${date}&symbol=${symbol}`)
                    .then(response => {
                        console.log('Response received:', response.status);
                        return response.json();
                    })
                    .then(data => {
                        console.log('Strikes data received:', data);
                        
                        if (data.error) {
                            console.error('Error from server:', data.error);
                            showError(data.error);
                            return;
                        }

                        // Populate call strikes
                        callStrikeSelect.innerHTML = '<option value="">Select Call Strike</option>';
                        if (data.call_strikes && data.call_strikes.length > 0) {
                            data.call_strikes.forEach(strike => {
                                const option = document.createElement('option');
                                option.value = strike;
                                option.textContent = strike.toLocaleString();
                                callStrikeSelect.appendChild(option);
                            });
                            console.log('Populated call strikes:', data.call_strikes.length);
                        } else {
                            console.log('No call strikes found');
                        }

                        // Populate put strikes
                        putStrikeSelect.innerHTML = '<option value="">Select Put Strike</option>';
                        if (data.put_strikes && data.put_strikes.length > 0) {
                            data.put_strikes.forEach(strike => {
                                const option = document.createElement('option');
                                option.value = strike;
                                option.textContent = strike.toLocaleString();
                                putStrikeSelect.appendChild(option);
                            });
                            console.log('Populated put strikes:', data.put_strikes.length);
                        } else {
                            console.log('No put strikes found');
                        }

                        callStrikeSelect.disabled = false;
                        putStrikeSelect.disabled = false;
                        showSuccess('Strikes loaded successfully');
                    })
                    .catch(error => {
                        console.error('Error loading strikes:', error);
                        showError('Failed to load strikes');
                    });
            }

            function loadExpiries() {
                const date = getSelectedDate();
                const symbol = symbolSelect.value;
                const callStrike = callStrikeSelect.value;
                const putStrike = putStrikeSelect.value;

                console.log('Loading expiries with params:', { date, symbol, callStrike, putStrike });

                if (!date || !callStrike || !putStrike) {
                    console.log('Missing required parameters for expiry loading');
                    return;
                }

                const url = `/get_straddle_expiries?date=${date}&symbol=${symbol}&call_strike=${callStrike}&put_strike=${putStrike}`;
                console.log('Fetching from URL:', url);

                fetch(url)
                    .then(response => {
                        console.log('Response status:', response.status);
                        return response.json();
                    })
                    .then(data => {
                        console.log('Received expiry data:', data);
                        
                        if (data.error) {
                            console.error('Error from server:', data.error);
                            showError(data.error);
                            return;
                        }

                        // Use common expiries for straddle
                        expirySelect.innerHTML = '<option value="">Select Expiry</option>';
                        
                        if (data.common_expiries && data.common_expiries.length > 0) {
                            data.common_expiries.forEach(expiry => {
                                const option = document.createElement('option');
                                option.value = expiry;
                                option.textContent = expiry;
                                expirySelect.appendChild(option);
                            });
                            console.log(`Loaded ${data.common_expiries.length} expiry options`);
                        } else {
                            console.log('No expiry options available');
                            const option = document.createElement('option');
                            option.value = '';
                            option.textContent = 'No expiries available';
                            expirySelect.appendChild(option);
                        }

                        expirySelect.disabled = false;
                        generateBtn.disabled = false;
                        showSuccess('Expiries loaded successfully');
                    })
                    .catch(error => {
                        console.error('Error loading expiries:', error);
                        showError('Failed to load expiries');
                    });
            }

            function resetStrikesAndExpiry() {
                callStrikeSelect.innerHTML = '<option value="">Select Date First</option>';
                putStrikeSelect.innerHTML = '<option value="">Select Date First</option>';
                expirySelect.innerHTML = '<option value="">Select Strikes First</option>';
                
                callStrikeSelect.disabled = true;
                putStrikeSelect.disabled = true;
                expirySelect.disabled = true;
                generateBtn.disabled = true;
            }

            async function generateStraddleChart() {
                const formData = new FormData(form);
                
                // Get the selected date from the new date selector
                const selectedDate = getSelectedDate();
                if (!selectedDate) {
                    showError('Please select a date');
                    return;
                }
                
                // Add the date to the form data
                formData.set('date', selectedDate);
                
                // Handle indicators from new icon-based selection system
                const selectedIndicatorsList = getSelectedIndicators();
                console.log('DEBUG: Selected indicators from icon system:', selectedIndicatorsList);
                console.log('DEBUG: Number of selected indicators:', selectedIndicatorsList.length);
                
                // Clear any existing indicator data and add selected indicators
                formData.delete('indicators');
                
                // Add each selected indicator to form data
                if (selectedIndicatorsList.length > 0) {
                    selectedIndicatorsList.forEach(indicator => {
                        formData.append('indicators', indicator);
                        console.log('DEBUG: Added indicator to form data:', indicator);
                    });
                } else {
                    console.log('DEBUG: No indicators selected');
                }
                
                // Debug: Check selected indicators
                const selectedIndicators = [];
                for (let [key, value] of formData.entries()) {
                    if (key === 'indicators') {
                        selectedIndicators.push(value);
                    }
                }
                console.log('Selected indicators:', selectedIndicators);
                console.log('Timeframe being sent:', document.getElementById('timeframe').value);
                console.log('Date being sent:', selectedDate);
                
                loading.style.display = 'block';
                chartSection.style.display = 'none';
                hideMessages();

                // Ensure timeframe is included
                const timeframeValue = document.getElementById('timeframe').value;
                if (timeframeValue) {
                    formData.set('timeframe', timeframeValue);
                    console.log('Added timeframe to FormData:', timeframeValue);
                }

                try {
                    const response = await fetch('/generate_straddle_chart', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const data = await response.json();
                    loading.style.display = 'none';
                    
                    if (data.error) {
                        showError(data.error);
                        return;
                    }

                    if (data.success) {
                        await displayChart(data);
                        showSuccess('Straddle chart generated successfully');
                    }
                } catch (error) {
                    loading.style.display = 'none';
                    console.error('Error generating chart:', error);
                    showError('Failed to generate straddle chart');
                }
            }

            async function displayChart(data) {
                // Clean up existing charts before creating new ones
                if (currentChart) {
                    try {
                        if (currentChart && typeof currentChart.remove === 'function' && !currentChart._disposed) {
                            currentChart.remove();
                            console.log('Main chart disposed successfully');
                        }
                    } catch (e) {
                        console.log('Main chart disposal error:', e.message);
                    } finally {
                        currentChart = null;
                    }
                }
                
                // Clean up indicator charts
                if (window.macdChartInstance) {
                    try {
                        if (window.macdChartInstance && typeof window.macdChartInstance.remove === 'function' && !window.macdChartInstance._disposed) {
                            window.macdChartInstance.remove();
                            console.log('MACD chart disposed successfully');
                        }
                    } catch (e) {
                        console.log('MACD chart disposal error:', e.message);
                    } finally {
                        window.macdChartInstance = null;
                    }
                }
                
                if (window.rsiChartInstance) {
                    try {
                        if (window.rsiChartInstance && typeof window.rsiChartInstance.remove === 'function' && !window.rsiChartInstance._disposed) {
                            window.rsiChartInstance.remove();
                            console.log('RSI chart disposed successfully');
                        }
                    } catch (e) {
                        console.log('RSI chart disposal error:', e.message);
                    } finally {
                        window.rsiChartInstance = null;
                    }
                }
                
                document.getElementById('chartTitle').textContent = data.chart_title;
                
                // Store chart data for switching between chart types
                currentChartData = data.chart_data;
                currentChartTitle = data.chart_title;
                
                // Try to create interactive chart first
                try {
                    await createInteractiveChart(data.chart_data, data.chart_title, 'line');
                    
                    // Hide static image and show interactive chart
                    document.getElementById('chartImage').style.display = 'none';
                    document.querySelector('.interactive-chart-container').style.display = 'block';
                    document.querySelector('.chart-type-toggle').style.display = 'flex';
                } catch (error) {
                    console.error('Failed to create interactive chart:', error);
                    
                    // Fallback to static image
                    document.getElementById('chartImage').src = `data:image/png;base64,${data.chart_base64}`;
                    document.getElementById('chartImage').style.display = 'block';
                    document.querySelector('.interactive-chart-container').style.display = 'none';
                    document.querySelector('.chart-type-toggle').style.display = 'none';
                }
                
                // Display chart information
                const chartInfo = document.getElementById('chartInfo');
                chartInfo.innerHTML = `
                    <div class="info-card">
                        <h4>Records</h4>
                        <p>${data.record_count}</p>
                    </div>
                    <div class="info-card">
                        <h4>Market Open</h4>
                        <p>${data.time_frame.market_open}</p>
                    </div>
                    <div class="info-card">
                        <h4>Market Close</h4>
                        <p>${data.time_frame.market_close}</p>
                    </div>
                    <div class="info-card">
                        <h4>Duration</h4>
                        <p>${data.time_frame.trading_duration}</p>
                    </div>
                    <div class="info-card">
                        <h4>Call Strike</h4>
                        <p>${data.call_strike}</p>
                    </div>
                    <div class="info-card">
                        <h4>Put Strike</h4>
                        <p>${data.put_strike}</p>
                    </div>
                    <div class="info-card">
                        <h4>Timeframe</h4>
                        <p>${data.timeframe || 1} min</p>
                    </div>
                `;
                
                chartSection.style.display = 'block';
            }

            // Global variable to store current chart
            let currentChart = null;
            let isChartDisposed = false; // Global flag to track disposal state

            // VWAP calculation function
            function calculateVWAP(candlestickData) {
                try {
                    console.log('Calculating VWAP for', candlestickData.length, 'data points');
                    
                    if (!candlestickData || candlestickData.length === 0) {
                        console.warn('No data provided for VWAP calculation');
                        return [];
                    }
                    
                    const vwapValues = [];
                    let cumulativeTPV = 0; // Cumulative Typical Price × Volume
                    let cumulativeVolume = 0; // Cumulative Volume
                    
                    for (let i = 0; i < candlestickData.length; i++) {
                        const candle = candlestickData[i];
                        
                        // Calculate typical price: (High + Low + Close) / 3
                        const typicalPrice = (candle.high + candle.low + candle.close) / 3;
                        
                        // For now, assume volume = 1 for each data point
                        // In a real scenario, you'd have actual volume data
                        const volume = 1;
                        
                        // Accumulate values
                        cumulativeTPV += typicalPrice * volume;
                        cumulativeVolume += volume;
                        
                        // Calculate VWAP for this point
                        const vwap = cumulativeTPV / cumulativeVolume;
                        vwapValues.push(vwap);
                    }
                    
                    console.log('VWAP calculation completed. First few values:', vwapValues.slice(0, 5));
                    console.log('VWAP calculation completed. Last few values:', vwapValues.slice(-5));
                    
                    return vwapValues;
                } catch (error) {
                    console.error('Error in VWAP calculation:', error);
                    return [];
                }
            }

            // MACD calculation function
            function calculateMACD(candlestickData, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
                try {
                    console.log('Calculating MACD for', candlestickData.length, 'data points');
                    console.log('MACD parameters - Fast:', fastPeriod, 'Slow:', slowPeriod, 'Signal:', signalPeriod);
                    
                    if (!candlestickData || candlestickData.length === 0) {
                        console.warn('No data provided for MACD calculation');
                        return { macdLine: [], signalLine: [], histogram: [] };
                    }
                    
                    if (candlestickData.length < Math.max(fastPeriod, slowPeriod, signalPeriod)) {
                        console.warn('Insufficient data for MACD calculation');
                        return { macdLine: [], signalLine: [], histogram: [] };
                    }
                    
                    // Calculate EMAs
                    const fastEMA = calculateEMA(candlestickData, fastPeriod);
                    const slowEMA = calculateEMA(candlestickData, slowPeriod);
                    
                    if (!fastEMA || !slowEMA) {
                        console.error('Failed to calculate EMAs for MACD');
                        return { macdLine: [], signalLine: [], histogram: [] };
                    }
                    
                    // Calculate MACD Line (Fast EMA - Slow EMA)
                    const macdLine = [];
                    for (let i = 0; i < candlestickData.length; i++) {
                        if (fastEMA[i] !== undefined && slowEMA[i] !== undefined && 
                            !isNaN(fastEMA[i]) && !isNaN(slowEMA[i])) {
                            const macdValue = fastEMA[i] - slowEMA[i];
                            macdLine.push(macdValue);
                        } else {
                            macdLine.push(NaN); // Invalid data for early periods
                        }
                    }
                    
                    // Calculate Signal Line (EMA of MACD Line)
                    const signalLine = calculateEMAFromValues(macdLine, signalPeriod);
                    
                    // Calculate Histogram (MACD Line - Signal Line)
                    const histogram = [];
                    for (let i = 0; i < candlestickData.length; i++) {
                        if (macdLine[i] !== undefined && signalLine[i] !== undefined && 
                            !isNaN(macdLine[i]) && !isNaN(signalLine[i])) {
                            const histValue = macdLine[i] - signalLine[i];
                            histogram.push(histValue);
                        } else {
                            histogram.push(NaN); // Invalid data for early periods
                        }
                    }
                    
                    console.log('MACD calculation completed');
                    
                    // Filter out NaN values for range calculation
                    const validMacdLine = macdLine.filter(val => !isNaN(val));
                    const validSignalLine = signalLine.filter(val => !isNaN(val));
                    const validHistogram = histogram.filter(val => !isNaN(val));
                    
                    if (validMacdLine.length > 0) {
                        console.log('MACD Line range:', Math.min(...validMacdLine).toFixed(4), 'to', Math.max(...validMacdLine).toFixed(4));
                    }
                    if (validSignalLine.length > 0) {
                        console.log('Signal Line range:', Math.min(...validSignalLine).toFixed(4), 'to', Math.max(...validSignalLine).toFixed(4));
                    }
                    if (validHistogram.length > 0) {
                        console.log('Histogram range:', Math.min(...validHistogram).toFixed(4), 'to', Math.max(...validHistogram).toFixed(4));
                    }
                    
                    return { macdLine, signalLine, histogram };
                } catch (error) {
                    console.error('Error in MACD calculation:', error);
                    return { macdLine: [], signalLine: [], histogram: [] };
                }
            }

            // Helper function to calculate EMA from an array of values
            function calculateEMAFromValues(values, period) {
                try {
                    if (values.length === 0) return [];
                    
                    const ema = [];
                    const multiplier = 2 / (period + 1);
                    
                    // Calculate SMA for the first 'period' values (standard EMA initialization)
                    let sum = 0;
                    for (let i = 0; i < Math.min(period, values.length); i++) {
                        sum += values[i];
                    }
                    const initialSMA = sum / Math.min(period, values.length);
                    ema.push(initialSMA);
                    
                    // Calculate EMA for remaining values
                    for (let i = 1; i < values.length; i++) {
                        const emaValue = (values[i] * multiplier) + (ema[i - 1] * (1 - multiplier));
                        ema.push(emaValue);
                    }
                    
                    return ema;
                } catch (error) {
                    console.error('Error calculating EMA from values:', error);
                    return [];
                }
            }

            // EMA calculation function
            function calculateEMA(candlestickData, period = 20) {
                try {
                    console.log('Calculating EMA for', candlestickData.length, 'data points with period', period);
                    
                    if (!candlestickData || candlestickData.length === 0) {
                        console.warn('No data provided for EMA calculation');
                        return [];
                    }
                    
                    if (candlestickData.length < period) {
                        console.warn('Insufficient data for EMA calculation. Need at least', period, 'data points');
                        return [];
                    }
                    
                    const alpha = 2.0 / (period + 1);
                    const emaValues = [candlestickData[0].close];
                    
                    for (let i = 1; i < candlestickData.length; i++) {
                        const ema = alpha * candlestickData[i].close + (1 - alpha) * emaValues[emaValues.length - 1];
                        emaValues.push(ema);
                    }
                    
                    console.log('EMA calculation completed. Values:', emaValues.length);
                    return emaValues;
                } catch (error) {
                    console.error('Error calculating EMA:', error);
                    return [];
                }
            }

            // RSI calculation function
            function calculateRSI(candlestickData, period = 14) {
                try {
                    console.log('Calculating RSI for', candlestickData.length, 'data points with period', period);
                    
                    if (!candlestickData || candlestickData.length === 0) {
                        console.warn('No data provided for RSI calculation');
                        return [];
                    }
                    
                    if (candlestickData.length < period + 1) {
                        console.warn('Insufficient data for RSI calculation. Need at least', period + 1, 'data points');
                        return [];
                    }
                    
                    const rsiValues = [];
                    
                    // Calculate price changes
                    const priceChanges = [];
                    for (let i = 1; i < candlestickData.length; i++) {
                        const change = candlestickData[i].close - candlestickData[i - 1].close;
                        priceChanges.push(change);
                    }
                    
                    console.log('Price changes calculated:', priceChanges.length);
                    console.log('First few price changes:', priceChanges.slice(0, 5));
                    console.log('Last few price changes:', priceChanges.slice(-5));
                    
                    // Separate gains and losses
                    const gains = priceChanges.map(change => change > 0 ? change : 0);
                    const losses = priceChanges.map(change => change < 0 ? Math.abs(change) : 0);
                    
                    // Calculate initial average gain and loss (SMA) for the first period
                    let avgGain = 0;
                    let avgLoss = 0;
                    
                    // Calculate initial average gain and loss over the first period
                    for (let i = 0; i < period; i++) {
                        avgGain += gains[i];
                        avgLoss += losses[i];
                    }
                    
                    avgGain = avgGain / period;
                    avgLoss = avgLoss / period;
                    
                    // First RSI value (after period)
                    if (avgLoss === 0) {
                        rsiValues.push(100);
                    } else {
                        const rs = avgGain / avgLoss;
                        const rsi = 100 - (100 / (1 + rs));
                        rsiValues.push(rsi);
                    }
                    
                    console.log('First RSI calculation - avgGain:', avgGain.toFixed(4), 'avgLoss:', avgLoss.toFixed(4), 'RSI:', rsiValues[0].toFixed(2));
                    
                    // Calculate remaining RSI values using Wilder's smoothing
                    // FIXED: The loop should run for all remaining price changes after the initial calculation
                    console.log('Starting RSI loop calculation...');
                    for (let i = period; i < priceChanges.length; i++) {
                        // Wilder's smoothing: new_avg = (prev_avg * (period-1) + current_value) / period
                        avgGain = ((avgGain * (period - 1)) + gains[i]) / period;
                        avgLoss = ((avgLoss * (period - 1)) + losses[i]) / period;
                        
                        if (avgLoss === 0) {
                            rsiValues.push(100);
                        } else {
                            const rs = avgGain / avgLoss;
                            const rsi = 100 - (100 / (1 + rs));
                            rsiValues.push(rsi);
                        }
                        
                        // Debug every 50 iterations
                        if (i % 50 === 0 || i === priceChanges.length - 1) {
                            console.log(`RSI calculation progress: i=${i}, rsiValues.length=${rsiValues.length}`);
                        }
                    }
                    console.log('RSI loop calculation completed. Final rsiValues.length:', rsiValues.length);
                    
                    console.log('RSI calculation details:');
                    console.log('Price changes count:', priceChanges.length);
                    console.log('Gains/losses count:', gains.length);
                    console.log('RSI values calculated:', rsiValues.length);
                    console.log('Expected RSI count (priceChanges.length):', priceChanges.length);
                    
                    // Debug: Show the loop bounds
                    console.log('RSI calculation loop bounds:');
                    console.log('Period (start index):', period);
                    console.log('Price changes length (end index):', priceChanges.length);
                    console.log('Loop should run from', period, 'to', priceChanges.length - 1);
                    console.log('Expected iterations:', priceChanges.length - period);
                    console.log('Initial RSI values count (after first calculation):', rsiValues.length);
                    console.log('Expected total RSI values:', priceChanges.length - period + 1);
                    
                    // Debug: Show the relationship between candlestick data and RSI
                    console.log('Data relationship:');
                    console.log('Candlestick data points:', candlestickData.length);
                    console.log('Price changes (candlestickData.length - 1):', candlestickData.length - 1);
                    console.log('RSI values (should equal price changes):', rsiValues.length);
                    
                    // CRITICAL DEBUG: Check if RSI calculation is correct
                    const expectedRSICount = priceChanges.length - period + 1;
                    if (rsiValues.length !== expectedRSICount) {
                        console.error('RSI CALCULATION BUG: RSI values count does not match expected count!');
                        console.error('This will cause the RSI chart to end earlier than expected!');
                        console.error('Expected RSI values:', expectedRSICount, 'Actual RSI values:', rsiValues.length);
                    } else {
                        console.log('✅ RSI calculation is correct - all data points accounted for');
                        console.log('RSI values:', rsiValues.length, 'Expected:', expectedRSICount);
                    }
                    
                    console.log('RSI calculation completed');
                    console.log('RSI range:', Math.min(...rsiValues).toFixed(2), 'to', Math.max(...rsiValues).toFixed(2));
                    console.log('RSI values count:', rsiValues.length);
                    console.log('Input candlestick data count:', candlestickData.length);
                    console.log('Expected RSI count (should be candlestickData.length - 1):', candlestickData.length - 1);
                    
                    // Debug: Show first and last few RSI values
                    if (rsiValues.length > 0) {
                        console.log('First 3 RSI values:', rsiValues.slice(0, 3));
                        console.log('Last 3 RSI values:', rsiValues.slice(-3));
                    }
                    
                    // Explain the time discrepancy
                    console.log('=== RSI TIME DISCREPANCY EXPLANATION ===');
                    console.log('Main Chart Time Range: 9:17 AM to 15:29 PM (211 data points)');
                    console.log('RSI Chart Time Range: 9:19 AM to 15:29 PM (210 data points)');
                    console.log('Reason: RSI requires previous price data for calculation');
                    console.log('Missing Data: 9:18 AM data point is missing from source data');
                    console.log('This is NORMAL behavior - RSI cannot be calculated for the first candlestick');
                    console.log('==========================================');
                    
                    return rsiValues;
                } catch (error) {
                    console.error('Error calculating RSI:', error);
                    return [];
                }
            }

            // Function to calculate EMA from candlestick data
            function calculateEMA(candlestickData, period) {
                try {
                    console.log('Calculating EMA with period:', period, 'for', candlestickData.length, 'data points');
                    
                    if (!candlestickData || candlestickData.length === 0) {
                        console.warn('No data provided for EMA calculation');
                        return [];
                    }
                    
                    if (candlestickData.length < period) {
                        console.warn('Insufficient data for EMA calculation');
                        return [];
                    }
                    
                    // Extract closing prices
                    const closePrices = candlestickData.map(candle => candle.close);
                    
                    // Calculate EMA using the helper function
                    const emaValues = calculateEMAFromValues(closePrices, period);
                    
                    console.log('EMA calculation completed. Period:', period, 'Values:', emaValues.length);
                    console.log('EMA range:', Math.min(...emaValues).toFixed(4), 'to', Math.max(...emaValues).toFixed(4));
                    
                    return emaValues;
                } catch (error) {
                    console.error('Error in EMA calculation:', error);
                    return [];
                }
            }

            async function createInteractiveChart(chartData, title, chartType = 'line') {
                console.log('=== CREATE INTERACTIVE CHART CALLED ===');
                console.log('Chart type requested:', chartType);
                console.log('Chart data length:', chartData ? chartData.length : 'undefined');
                console.log('Chart title:', title);
                
                
                // Check if this is a higher timeframe chart
                const timeframeMatch = title.match(/(\d+)-Minute/);
                if (timeframeMatch) {
                    const timeframe = parseInt(timeframeMatch[1]);
                    console.log(`Detected ${timeframe}-minute timeframe chart`);
                    if (timeframe > 1) {
                        console.log('This should use LightweightCharts for professional candlesticks');
                    }
                }
                
                // Check if we have data
                if (!chartData || chartData.length === 0) {
                    console.error('No chart data provided');
                    return;
                }

                if (chartType === 'candlestick') {
                    // Use LightweightCharts for proper candlestick rendering
                    console.log('=== CREATING CANDLESTICK CHART ===');
                    console.log('Using LightweightCharts for candlestick chart');
                    await createLightweightCandlestickChart(chartData, title);
                } else {
                    console.log('=== CREATING LINE CHART ===');
                    createChartJSLineChart(chartData, title);
                }
            }

            function createContinuousTimeAxis(chartData) {
                // This function is no longer needed - we'll use the original approach
                // with better X-axis configuration instead
                console.log('createContinuousTimeAxis called but not needed - using original labels');
                return chartData.map(item => item.time);
            }

            // Global flag to prevent duplicate chart creation
            let isCreatingChart = false;
            let isSwitchingChartType = false; // Flag to prevent async operations during chart switching
            let isLineChartActive = false; // Flag to indicate when line chart is active (no sub-charts)
            
            // Global flag to track MACD tooltip visibility
            let macdTooltipVisible = false;
            
            
            
            async function createLightweightCandlestickChart(chartData, title) {
                // Prevent duplicate chart creation
                if (isCreatingChart) {
                    console.log('Chart creation already in progress, skipping...');
                    return;
                }
                
                isCreatingChart = true;
                console.log('=== CREATING LIGHTWEIGHT CANDLESTICK CHART ===');
                console.log('Chart data:', chartData);
                console.log('Title:', title);
                
                // Check if LightweightCharts is available
                if (typeof LightweightCharts === 'undefined') {
                    console.error('LightweightCharts library not loaded!');
                    console.log('Falling back to Chart.js candlestick implementation...');
                    createChartJSCandlestickChart(chartData, title);
                    return;
                }
                
                console.log('LightweightCharts library is available');
                console.log('LightweightCharts version:', LightweightCharts.version || 'unknown');
                console.log('LightweightCharts methods:', Object.getOwnPropertyNames(LightweightCharts));
                
                // Destroy existing chart if it exists
                if (currentChart) {
                    console.log('Removing existing chart');
                try {
                    if (currentChart && typeof currentChart.remove === 'function' && !currentChart._disposed) {
                        currentChart.remove();
                        console.log('Chart disposed successfully');
                    }
                } catch (e) {
                    console.log('Chart disposal error (chart may already be disposed):', e.message);
                } finally {
                    currentChart = null;
                }
                }
                
                // Hide line chart container, show candlestick container
                document.querySelector('.interactive-chart-container').style.display = 'none';
                document.querySelector('.candlestick-chart-container').style.display = 'block';
                
                // Simple: Show sub-chart containers for candlestick chart
                isLineChartActive = false;
                const macdContainer = document.getElementById('macdChart');
                const rsiContainer = document.getElementById('rsiChart');
                
                if (macdContainer) {
                    macdContainer.style.display = 'block';
                }
                
                if (rsiContainer) {
                    rsiContainer.style.display = 'block';
                }

                const chartContainer = document.getElementById('candlestickChart');
                
                // Also clear the container to prevent any leftover elements
                if (chartContainer) {
                    chartContainer.innerHTML = '';
                    console.log('Chart container cleared');
                }
                if (!chartContainer) {
                    console.error('Candlestick chart container not found');
                    return;
                }
                
                console.log('Chart container found:', chartContainer);
                console.log('Container dimensions:', chartContainer.clientWidth, 'x', chartContainer.clientHeight);

                // Immediately clear any existing chart elements to prevent conflicts
                chartContainer.innerHTML = '';
                
                // Wait a moment to ensure cleanup is complete before creating new chart
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Reset disposal flag - we're creating a new chart
                isChartDisposed = false;
                
                // Create the chart
                console.log('Creating LightweightCharts chart...');
                
                // Container already cleared above to prevent conflicts
                
                let chart;
                try {
                    chart = LightweightCharts.createChart(chartContainer, {
                        width: chartContainer.clientWidth,
                        height: 400,
                        layout: {
                            background: { color: '#0a0a0a' },
                            textColor: '#cccccc',
                            fontFamily: 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif',
                        },
                        grid: {
                            vertLines: { color: '#333333', alpha: 0.15, style: 1 },
                            horzLines: { color: '#333333', alpha: 0.15, style: 1 },
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal,
                            vertLine: {
                                color: '#00ccff',
                                width: 2,
                                style: 3,
                                labelBackgroundColor: '#00ccff',
                                labelTextColor: '#ffffff',
                                labelVisible: false,
                            },
                            horzLine: {
                                color: '#00ccff',
                                width: 2,
                                style: 3,
                                labelBackgroundColor: '#00ccff',
                                labelTextColor: '#ffffff',
                                labelVisible: false,
                            },
                        },
                        rightPriceScale: {
                            borderColor: '#333333',
                            textColor: '#cccccc',
                            scaleMargins: {
                                top: 0.1,
                                bottom: 0.1,
                            },
                        },
                        timeScale: {
                            borderColor: '#333333',
                            textColor: '#cccccc',
                            timeVisible: true,
                            secondsVisible: false,
                            rightOffset: 12,
                            barSpacing: 6,
                            minBarSpacing: 3,
                            borderVisible: true,
                            fixLeftEdge: true,
                            fixRightEdge: true,
                            tickMarkFormatter: (time, tickMarkType, locale) => {
                                const date = new Date(time * 1000);
                                return date.toLocaleTimeString('en-IN', {
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    hour12: true
                                });
                            },
                        },
                        leftPriceScale: {
                            visible: false,
                        },
                        watermark: {
                            visible: false,
                        },
                    });
                    console.log('Chart created successfully:', chart);
                } catch (error) {
                    console.error('Error creating LightweightCharts chart:', error);
                    console.log('Attempting to continue with LightweightCharts...');
                    // Don't return immediately, try to continue
                }

                // Verify chart was created successfully
                if (!chart) {
                    console.error('Chart creation failed, falling back to Chart.js');
                    createChartJSCandlestickChart(chartData, title);
                    isCreatingChart = false;
                    return;
                }
                
                // Add candlestick series
                console.log('Adding candlestick series...');
                console.log('Available chart methods:', Object.getOwnPropertyNames(chart));
                
                let candlestickSeries;
                try {
                    // Try different method names for different versions
                    if (typeof chart.addCandlestickSeries === 'function') {
                        console.log('Using addCandlestickSeries method');
                        candlestickSeries = chart.addCandlestickSeries({
                            upColor: '#00ff88',
                            downColor: '#ff4444',
                            borderDownColor: '#ff4444',
                            borderUpColor: '#00ff88',
                            wickDownColor: '#ff4444',
                            wickUpColor: '#00ff88',
                            borderVisible: false,
                            wickThickness: 2,
                            priceFormat: {
                                type: 'price',
                                precision: 2,
                                minMove: 0.01,
                            }
                        });
                    } else if (typeof chart.addSeries === 'function') {
                        console.log('Using addSeries method');
                        candlestickSeries = chart.addSeries({
                            type: 'Candlestick',
                            upColor: '#00ff88',
                            downColor: '#ff4444',
                            borderDownColor: '#ff4444',
                            borderUpColor: '#00ff88',
                            wickDownColor: '#ff4444',
                            wickUpColor: '#00ff88',
                            borderVisible: false,
                            wickThickness: 2,
                        });
                    } else {
                        throw new Error('No suitable method found to add candlestick series');
                    }
                    console.log('Candlestick series added successfully:', candlestickSeries);
                } catch (error) {
                    console.error('Error adding candlestick series:', error);
                    console.log('Attempting to continue with LightweightCharts...');
                    // Don't fall back immediately, try to continue
                }

                // Verify the series was created successfully
                if (!candlestickSeries) {
                    console.error('Candlestick series creation failed');
                    console.log('Attempting to continue with LightweightCharts...');
                    // Don't fall back immediately, try to continue
                }

                // Get the selected date from the date dropdowns (straddle chart)
                const yearSelect = document.getElementById('yearSelect');
                const monthSelect = document.getElementById('monthSelect');
                const daySelect = document.getElementById('daySelect');
                
                let selectedDate;
                if (yearSelect && monthSelect && daySelect && 
                    yearSelect.value && monthSelect.value && daySelect.value) {
                    selectedDate = `${yearSelect.value}-${monthSelect.value}-${daySelect.value}`;
                } else {
                    // Fallback: use current date if dropdowns not populated
                    const today = new Date();
                    selectedDate = today.toISOString().split('T')[0];
                    console.warn('Date dropdowns not populated, using current date:', selectedDate);
                }
                
                // Prepare data for the chart with proper timestamps
                console.log('Processing chart data...');
                console.log('Sample raw data:', chartData.slice(0, 3));
                console.log('Date input value:', selectedDate);
                
                const candlestickData = chartData.map((candle, index) => {
                    
                    // Parse the time string - handle both HH:MM:SS and HH:MM formats
                    let timeString = candle.time;
                    console.log(`Processing time: "${timeString}" for candle ${index}`);
                    
                    // Handle different time formats from different timeframes
                    let hours, minutes, seconds;
                    const timeParts = timeString.split(':');
                    
                    if (timeParts.length === 3) {
                        // Format: HH:MM:SS (1-minute data)
                        hours = parseInt(timeParts[0]);
                        minutes = parseInt(timeParts[1]);
                        seconds = parseInt(timeParts[2]);
                        console.log(`3-part time format: ${hours}:${minutes}:${seconds}`);
                    } else if (timeParts.length === 2) {
                        // Format: HH:MM (3-minute, 5-minute, etc. data)
                        hours = parseInt(timeParts[0]);
                        minutes = parseInt(timeParts[1]);
                        seconds = 0; // Set seconds to 0 for higher timeframes
                        console.log(`2-part time format: ${hours}:${minutes}:00`);
                    } else {
                        console.error(`Invalid time format: "${timeString}"`);
                        // Fallback: use index as time offset
                        const fallbackTime = new Date();
                        fallbackTime.setHours(9, 15 + index, 0, 0); // Start from 9:15 AM
                        return {
                            time: Math.floor(fallbackTime.getTime() / 1000),
                            open: parseFloat(candle.open),
                            high: parseFloat(candle.high),
                            low: parseFloat(candle.low),
                            close: parseFloat(candle.close)
                        };
                    }
                    
                    // Create a timestamp for the selected date with the given time
                    // Use local timezone to avoid timezone conversion issues
                    const [year, month, day] = selectedDate.split('-');
                    const selectedDateTime = new Date(year, month - 1, day, hours, minutes, seconds, 0);
                    
                    // Validate the date
                    if (isNaN(selectedDateTime.getTime())) {
                        console.error(`Invalid date/time: ${selectedDate}T${hours}:${minutes}:${seconds}`);
                        // Fallback: use current date with the time
                        const today = new Date();
                        const fallbackDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                        fallbackDate.setHours(hours, minutes, seconds, 0);
                        selectedDateTime = fallbackDate;
                    }
                    
                    const dataPoint = {
                        time: Math.floor(selectedDateTime.getTime() / 1000), // Unix timestamp
                        open: parseFloat(candle.open),
                        high: parseFloat(candle.high),
                        low: parseFloat(candle.low),
                        close: parseFloat(candle.close)
                    };
                    
                    if (index < 3) { // Log first 3 data points for debugging
                        console.log(`Data point ${index}:`, {
                            originalTime: candle.time,
                            processedTime: `${hours}:${minutes}:${seconds}`,
                            selectedDate: selectedDate,
                            timestamp: dataPoint.time,
                            dateTime: selectedDateTime.toLocaleString('en-IN'),
                            dateTimeUTC: selectedDateTime.toISOString(),
                            localTime: selectedDateTime.toLocaleTimeString('en-IN', { hour12: true }),
                            ohlc: `${dataPoint.open}/${dataPoint.high}/${dataPoint.low}/${dataPoint.close}`
                        });
                    }
                    
                    return dataPoint;
                });
                
                console.log('Processed candlestick data:', candlestickData.length, 'points');
                console.log('First data point:', candlestickData[0]);
                console.log('Last data point:', candlestickData[candlestickData.length - 1]);

                // Set the data
                console.log('Setting data to candlestick series...');
                
                // Check if chart is disposed before setting data
                if (!chart || chart._disposed) {
                    console.log('Chart disposed during data processing, aborting chart creation');
                    return;
                }
                
                try {
                    candlestickSeries.setData(candlestickData);
                    console.log('Data set successfully');
                } catch (error) {
                    console.error('Error setting data:', error);
                    alert('Error setting chart data: ' + error.message);
                    return;
                }

                // Check if chart is still valid before adding any indicators
                if (isChartDisposed || !chart || chart._disposed) {
                    console.log('Chart disposed before adding indicators, skipping all indicators');
                    return;
                }
                
                // Add VWAP indicator if selected
                if (selectedIndicators.has('vwap')) {
                    console.log('VWAP indicator selected, calculating and plotting...');
                    
                    try {
                        // Calculate VWAP
                        const vwapValues = calculateVWAP(candlestickData);
                        console.log('VWAP values calculated:', vwapValues.length, 'points');
                        
                        if (vwapValues && vwapValues.length > 0) {
                            // Check if chart is disposed before adding series
                            if (!chart || chart._disposed) {
                                console.log('Chart disposed, skipping VWAP series creation');
                                return;
                            }
                            
                            // Create VWAP line series
                            const vwapSeries = chart.addLineSeries({
                                color: '#ff6b6b',
                                lineWidth: 2,
                                title: 'VWAP',
                                priceLineVisible: false,
                                lastValueVisible: false,
                                crosshairMarkerVisible: false,
                                lineType: 0, // Solid line
                            });
                            
                            // Set VWAP data
                            const vwapData = candlestickData.map((candle, index) => ({
                                time: candle.time,
                                value: vwapValues[index]
                            }));
                            
                            vwapSeries.setData(vwapData);
                            console.log('VWAP line added successfully');
                        } else {
                            console.warn('VWAP calculation returned no values');
                        }
                    } catch (error) {
                        console.error('Error adding VWAP indicator:', error);
                    }
                } else {
                    console.log('VWAP indicator not selected');
                }

                // Add MACD indicator if selected
                if (selectedIndicators.has('macd')) {
                    console.log('MACD indicator selected, calculating and plotting...');
                    
                    try {
                        // Check if we have enough data for MACD BEFORE calculating
                        if (candlestickData.length < 26) {
                            console.log('Insufficient data for MACD - showing message instead of chart');
                            console.log('Current data points:', candlestickData.length, '(need 26)');
                            
                            // Show MACD panel with insufficient data message
                            setTimeout(async () => {
                                // Simple check
                                if (isLineChartActive) {
                                    return;
                                }
                                try {
                                    await createMACDPanel(candlestickData, null); // Pass null to indicate insufficient data
                                } catch (error) {
                                    console.error('Error creating MACD insufficient data message:', error);
                                }
                            }, 50);
                        } else {
                            // Calculate MACD only if we have enough data
                            const macdData = calculateMACD(candlestickData);
                            console.log('MACD data calculated:', macdData.macdLine.length, 'points');
                            
                            if (macdData.macdLine.length > 0) {
                            // Create MACD panel below main chart with delay to ensure chart is ready
                            setTimeout(async () => {
                                // Simple check
                                if (isLineChartActive) {
                                    return;
                                }
                                try {
                                    await createMACDPanel(candlestickData, macdData);
                                    } catch (error) {
                                        console.error('Error creating MACD panel with delay:', error);
                                    }
                                }, 50);
                                
                                console.log('MACD indicator added successfully');
                            } else {
                                console.warn('MACD calculation returned no values');
                            }
                        }
                    } catch (error) {
                        console.error('Error adding MACD indicator:', error);
                    }
                } else {
                    console.log('MACD indicator not selected');
                    // Hide MACD panel if not selected
                    const macdPanel = document.getElementById('macdPanel');
                    if (macdPanel) {
                        macdPanel.style.display = 'none';
                    }
                    
                    // Hide MACD tooltip if it exists
                    const macdTooltip = document.getElementById('macdTooltip');
                    if (macdTooltip) {
                        macdTooltip.style.display = 'none';
                    }
                }

                // Add RSI indicator if selected
                if (selectedIndicators.has('rsi')) {
                    console.log('RSI indicator selected, calculating and plotting...');
                    
                    // Check if we have enough data for RSI (need at least 14 data points)
                    if (candlestickData.length < 14) {
                        console.log('Insufficient data for RSI:', candlestickData.length, 'data points (need 14)');
                        console.warn('⚠️ RSI insufficient data: Need at least 14 data points. Current:', candlestickData.length);
                        
                        // Show RSI panel with insufficient data message
                        setTimeout(async () => {
                            // Check if we're switching chart types or line chart is active
                            if (isSwitchingChartType || isLineChartActive) {
                                console.log('Skipping RSI panel creation - chart switching in progress or line chart active');
                                return;
                            }
                            try {
                                await createRSIPanel(candlestickData, null); // Pass null to indicate insufficient data
                            } catch (error) {
                                console.error('Error creating RSI insufficient data message:', error);
                            }
                        }, 150);
                    } else {
                        try {
                            // Calculate RSI
                            const rsiData = calculateRSI(candlestickData);
                        console.log('RSI data calculated:', rsiData.length, 'points');
                        console.log('Candlestick data points:', candlestickData.length);
                        console.log('Expected RSI points (candlestickData.length - 1):', candlestickData.length - 1);
                        
                        // Debug: Show time ranges
                        if (candlestickData.length > 0) {
                            const firstCandleTime = new Date(candlestickData[0].time * 1000).toLocaleTimeString();
                            const lastCandleTime = new Date(candlestickData[candlestickData.length - 1].time * 1000).toLocaleTimeString();
                            console.log('Candlestick time range:', firstCandleTime, 'to', lastCandleTime);
                            
                            // Show last few candlestick times to understand the data
                            console.log('Last 5 candlestick times:');
                            for (let i = Math.max(0, candlestickData.length - 5); i < candlestickData.length; i++) {
                                const time = new Date(candlestickData[i].time * 1000).toLocaleTimeString();
                                console.log(`  Candle ${i}: ${time}`);
                            }
                        }
                        
                        if (rsiData.length > 0) {
                        // Create RSI panel below main chart with delay to ensure chart is ready
                        setTimeout(() => {
                            // Check if we're switching chart types or line chart is active
                            if (isSwitchingChartType || isLineChartActive) {
                                console.log('Skipping RSI panel creation - chart switching in progress or line chart active');
                                return;
                            }
                            try {
                                createRSIPanel(candlestickData, rsiData);
                                } catch (error) {
                                    console.error('Error creating RSI panel with delay:', error);
                                }
                            }, 75); // Slightly longer delay to ensure MACD panel is created first
                            
                            console.log('RSI indicator added successfully');
                        } else {
                            console.warn('RSI calculation returned no values');
                        }
                        } catch (error) {
                            console.error('Error adding RSI indicator:', error);
                        }
                    }
                } else {
                    console.log('RSI indicator not selected');
                    // Hide RSI panel if not selected
                    const rsiPanel = document.getElementById('rsiPanel');
                    if (rsiPanel) {
                        rsiPanel.style.display = 'none';
                    }
                    
                    // Hide RSI tooltip if it exists
                    const rsiTooltip = document.getElementById('rsiTooltip');
                    if (rsiTooltip) {
                        rsiTooltip.style.display = 'none';
                    }
                }

                // Add EMA 20 indicator if selected
                if (selectedIndicators.has('ema_20')) {
                    console.log('EMA 20 indicator selected, calculating and plotting...');
                    
                    // Check if we have enough data for EMA 20 (need at least 20 data points)
                    if (candlestickData.length < 20) {
                        console.log('Insufficient data for EMA 20:', candlestickData.length, 'data points (need 20)');
                        console.warn('⚠️ EMA 20 insufficient data: Need at least 20 data points. Current:', candlestickData.length);
                        
                        // Show insufficient data message on the chart
                        try {
                            // Check if chart is disposed before adding series
                            if (!chart || chart._disposed) {
                                console.log('Chart disposed, skipping EMA 20 insufficient data series');
                                return;
                            }
                            
                            const ema20Series = chart.addLineSeries({
                                color: '#ff0000',
                                lineWidth: 2,
                                title: 'EMA 20 (Insufficient Data)',
                                priceLineVisible: false,
                                lastValueVisible: false,
                            });
                            
                            // Add a single point with insufficient data message
                            ema20Series.setData([{
                                time: candlestickData[candlestickData.length - 1].time,
                                value: candlestickData[candlestickData.length - 1].close
                            }]);
                            
                            // Add text annotation for insufficient data
                            const insufficientDataText = document.createElement('div');
                            insufficientDataText.style.cssText = `
                                position: absolute;
                                top: 10px;
                                left: 10px;
                                background: rgba(255, 107, 107, 0.9);
                                color: white;
                                padding: 5px 10px;
                                border-radius: 5px;
                                font-size: 12px;
                                font-weight: bold;
                                z-index: 1000;
                            `;
                            insufficientDataText.textContent = `⚠️ EMA 20: Need 20 data points (Current: ${candlestickData.length})`;
                            chartContainer.appendChild(insufficientDataText);
                            
                        } catch (error) {
                            console.error('Error showing EMA 20 insufficient data message:', error);
                        }
                    } else {
                        try {
                            // Calculate EMA 20
                            const emaData = calculateEMA(candlestickData, 20);
                        console.log('EMA 20 data calculated:', emaData.length, 'points');
                        
                        if (emaData && emaData.length > 0) {
                            // Check if chart is disposed before adding series
                            if (!chart || chart._disposed) {
                                console.log('Chart disposed, skipping EMA 20 series creation');
                                return;
                            }
                            
                            // Create EMA line series
                            const emaSeries = chart.addLineSeries({
                                color: '#ff0000',
                                lineWidth: 3,
                                title: 'EMA (Close, 20)',
                                priceLineVisible: false,
                                lastValueVisible: true,
                            });
                            
                            // Prepare EMA data for LightweightCharts
                            const emaChartData = candlestickData.map((candle, index) => {
                                if (index < emaData.length) {
                                    return {
                                        time: candle.time,
                                        value: emaData[index]
                                    };
                                }
                                return null;
                            }).filter(item => item !== null);
                            
                            console.log('EMA 20 chart data prepared:', emaChartData.length, 'points');
                            console.log('First few EMA values:', emaChartData.slice(0, 5));
                            
                            // Set EMA data
                            emaSeries.setData(emaChartData);
                            console.log('EMA 20 line added to chart successfully');
                        } else {
                            console.log('No EMA 20 data calculated');
                        }
                        } catch (error) {
                            console.error('Error calculating or plotting EMA 20:', error);
                        }
                    }
                } else {
                    console.log('EMA 20 indicator not selected');
                }

                // Add EMA 50 indicator if selected
                if (selectedIndicators.has('ema_50')) {
                    console.log('EMA 50 indicator selected, calculating and plotting...');
                    
                    // Check if we have enough data for EMA 50 (need at least 50 data points)
                    if (candlestickData.length < 50) {
                        console.log('Insufficient data for EMA 50:', candlestickData.length, 'data points (need 50)');
                        console.warn('⚠️ EMA 50 insufficient data: Need at least 50 data points. Current:', candlestickData.length);
                        
                        // Show insufficient data message on the chart
                        try {
                            // Check if chart is disposed before adding series
                            if (!chart || chart._disposed) {
                                console.log('Chart disposed, skipping EMA 50 insufficient data series');
                                return;
                            }
                            
                            const ema50Series = chart.addLineSeries({
                                color: '#00ff00',
                                lineWidth: 2,
                                title: 'EMA 50 (Insufficient Data)',
                                priceLineVisible: false,
                                lastValueVisible: false,
                            });
                            
                            // Add a single point with insufficient data message
                            ema50Series.setData([{
                                time: candlestickData[candlestickData.length - 1].time,
                                value: candlestickData[candlestickData.length - 1].close
                            }]);
                            
                            // Add text annotation for insufficient data
                            const insufficientDataText = document.createElement('div');
                            insufficientDataText.style.cssText = `
                                position: absolute;
                                top: 30px;
                                left: 10px;
                                background: rgba(255, 107, 107, 0.9);
                                color: white;
                                padding: 5px 10px;
                                border-radius: 5px;
                                font-size: 12px;
                                font-weight: bold;
                                z-index: 1000;
                            `;
                            insufficientDataText.textContent = `⚠️ EMA 50: Need 50 data points (Current: ${candlestickData.length})`;
                            chartContainer.appendChild(insufficientDataText);
                            
                        } catch (error) {
                            console.error('Error showing EMA 50 insufficient data message:', error);
                        }
                    } else {
                        try {
                            // Calculate EMA 50
                            const ema50Data = calculateEMA(candlestickData, 50);
                        console.log('EMA 50 data calculated:', ema50Data.length, 'points');
                        
                        if (ema50Data && ema50Data.length > 0) {
                            // Check if chart is disposed before adding series
                            if (!chart || chart._disposed) {
                                console.log('Chart disposed, skipping EMA 50 series creation');
                                return;
                            }
                            
                            // Create EMA 50 line series with different color
                            const ema50Series = chart.addLineSeries({
                                color: '#00ff00', // Green color to distinguish from EMA 20 (red)
                                lineWidth: 2,
                                title: 'EMA (Close, 50)',
                                priceLineVisible: false,
                                lastValueVisible: true,
                            });
                            
                            // Prepare EMA 50 data for LightweightCharts
                            const ema50ChartData = candlestickData.map((candle, index) => {
                                if (index < ema50Data.length) {
                                    return {
                                        time: candle.time,
                                        value: ema50Data[index]
                                    };
                                }
                                return null;
                            }).filter(item => item !== null);
                            
                            console.log('EMA 50 chart data prepared:', ema50ChartData.length, 'points');
                            console.log('First few EMA 50 values:', ema50ChartData.slice(0, 5));
                            
                            // Set EMA 50 data
                            ema50Series.setData(ema50ChartData);
                            console.log('EMA 50 line added to chart successfully');
                        } else {
                            console.log('No EMA 50 data calculated');
                        }
                        } catch (error) {
                            console.error('Error calculating or plotting EMA 50:', error);
                        }
                    }
                } else {
                    console.log('EMA 50 indicator not selected');
                }

                // Add EMA 100 indicator if selected
                if (selectedIndicators.has('ema_100')) {
                    console.log('EMA 100 indicator selected, calculating and plotting...');
                    
                    // Check if we have enough data for EMA 100 (need at least 100 data points)
                    if (candlestickData.length < 100) {
                        console.log('Insufficient data for EMA 100:', candlestickData.length, 'data points (need 100)');
                        console.warn('⚠️ EMA 100 insufficient data: Need at least 100 data points. Current:', candlestickData.length);
                        
                        // Show insufficient data message on the chart
                        try {
                            // Check if chart is disposed before adding series
                            if (!chart || chart._disposed) {
                                console.log('Chart disposed, skipping EMA 100 insufficient data series');
                                return;
                            }
                            
                            const ema100Series = chart.addLineSeries({
                                color: '#9b59b6',
                                lineWidth: 2,
                                title: 'EMA 100 (Insufficient Data)',
                                priceLineVisible: false,
                                lastValueVisible: false,
                            });
                            
                            // Add a single point with insufficient data message
                            ema100Series.setData([{
                                time: candlestickData[candlestickData.length - 1].time,
                                value: candlestickData[candlestickData.length - 1].close
                            }]);
                            
                            // Add text annotation for insufficient data
                            const insufficientDataText = document.createElement('div');
                            insufficientDataText.style.cssText = `
                                position: absolute;
                                top: 60px;
                                left: 10px;
                                background: rgba(155, 89, 182, 0.9);
                                color: white;
                                padding: 5px 10px;
                                border-radius: 5px;
                                font-size: 12px;
                                font-weight: bold;
                                z-index: 1000;
                            `;
                            insufficientDataText.textContent = `⚠️ EMA 100: Need 100 data points (Current: ${candlestickData.length})`;
                            chartContainer.appendChild(insufficientDataText);
                            
                        } catch (error) {
                            console.error('Error showing EMA 100 insufficient data message:', error);
                        }
                    } else {
                        try {
                            // Calculate EMA 100
                            const ema100Data = calculateEMA(candlestickData, 100);
                        console.log('EMA 100 data calculated:', ema100Data.length, 'points');
                        
                        if (ema100Data && ema100Data.length > 0) {
                            // Check if chart is disposed before adding series
                            if (!chart || chart._disposed) {
                                console.log('Chart disposed, skipping EMA 100 series creation');
                                return;
                            }
                            
                            // Create EMA 100 line series with different color
                            const ema100Series = chart.addLineSeries({
                                color: '#9b59b6', // Purple color to distinguish from other EMAs
                                lineWidth: 2,
                                title: 'EMA (Close, 100)',
                                priceLineVisible: false,
                                lastValueVisible: true,
                            });
                            
                            // Prepare EMA 100 data for LightweightCharts
                            const ema100ChartData = candlestickData.map((candle, index) => {
                                if (index < ema100Data.length) {
                                    return {
                                        time: candle.time,
                                        value: ema100Data[index]
                                    };
                                }
                                return null;
                            }).filter(item => item !== null);
                            
                            console.log('EMA 100 chart data prepared:', ema100ChartData.length, 'points');
                            console.log('First few EMA 100 values:', ema100ChartData.slice(0, 5));
                            
                            // Set EMA 100 data
                            ema100Series.setData(ema100ChartData);
                            console.log('EMA 100 line added to chart successfully');
                        } else {
                            console.log('No EMA 100 data calculated');
                        }
                        } catch (error) {
                            console.error('Error calculating or plotting EMA 100:', error);
                        }
                    }
                } else {
                    console.log('EMA 100 indicator not selected');
                }

                // Add EMA 200 indicator if selected
                if (selectedIndicators.has('ema_200')) {
                    console.log('EMA 200 indicator selected, calculating and plotting...');
                    
                    // Check if we have enough data for EMA 200 (need at least 200 data points)
                    if (candlestickData.length < 200) {
                        console.log('Insufficient data for EMA 200:', candlestickData.length, 'data points (need 200)');
                        console.warn('⚠️ EMA 200 insufficient data: Need at least 200 data points. Current:', candlestickData.length);
                        
                        // Show insufficient data message on the chart
                        try {
                            // Check if chart is disposed before adding series
                            if (!chart || chart._disposed) {
                                console.log('Chart disposed, skipping EMA 200 insufficient data series');
                                return;
                            }
                            
                            const ema200Series = chart.addLineSeries({
                                color: '#e74c3c',
                                lineWidth: 2,
                                title: 'EMA 200 (Insufficient Data)',
                                priceLineVisible: false,
                                lastValueVisible: false,
                            });
                            
                            // Add a single point with insufficient data message
                            ema200Series.setData([{
                                time: candlestickData[candlestickData.length - 1].time,
                                value: candlestickData[candlestickData.length - 1].close
                            }]);
                            
                            // Add text annotation for insufficient data
                            const insufficientDataText = document.createElement('div');
                            insufficientDataText.style.cssText = `
                                position: absolute;
                                top: 90px;
                                left: 10px;
                                background: rgba(231, 76, 60, 0.9);
                                color: white;
                                padding: 5px 10px;
                                border-radius: 5px;
                                font-size: 12px;
                                font-weight: bold;
                                z-index: 1000;
                            `;
                            insufficientDataText.textContent = `⚠️ EMA 200: Need 200 data points (Current: ${candlestickData.length})`;
                            chartContainer.appendChild(insufficientDataText);
                            
                        } catch (error) {
                            console.error('Error showing EMA 200 insufficient data message:', error);
                        }
                    } else {
                        try {
                            // Calculate EMA 200
                            const ema200Data = calculateEMA(candlestickData, 200);
                        console.log('EMA 200 data calculated:', ema200Data.length, 'points');
                        
                        if (ema200Data && ema200Data.length > 0) {
                            // Check if chart is disposed before adding series
                            if (!chart || chart._disposed) {
                                console.log('Chart disposed, skipping EMA 200 series creation');
                                return;
                            }
                            
                            // Create EMA 200 line series with different color
                            const ema200Series = chart.addLineSeries({
                                color: '#e74c3c', // Red color to distinguish from other EMAs
                                lineWidth: 2,
                                title: 'EMA (Close, 200)',
                                priceLineVisible: false,
                                lastValueVisible: true,
                            });
                            
                            // Prepare EMA 200 data for LightweightCharts
                            const ema200ChartData = candlestickData.map((candle, index) => {
                                if (index < ema200Data.length) {
                                    return {
                                        time: candle.time,
                                        value: ema200Data[index]
                                    };
                                }
                                return null;
                            }).filter(item => item !== null);
                            
                            console.log('EMA 200 chart data prepared:', ema200ChartData.length, 'points');
                            console.log('First few EMA 200 values:', ema200ChartData.slice(0, 5));
                            
                            // Set EMA 200 data
                            ema200Series.setData(ema200ChartData);
                            console.log('EMA 200 line added to chart successfully');
                        } else {
                            console.log('No EMA 200 data calculated');
                        }
                        } catch (error) {
                            console.error('Error calculating or plotting EMA 200:', error);
                        }
                    }
                } else {
                    console.log('EMA 200 indicator not selected');
                }

                // Handle window resize
                const resizeObserver = new ResizeObserver(entries => {
                    if (entries.length === 0 || entries[0].target !== chartContainer) { return; }
                    // Check if line chart is active to prevent disposal errors
                    if (isLineChartActive) { return; }
                    const newRect = entries[0].contentRect;
                    chart.applyOptions({ height: newRect.height, width: newRect.width });
                });

                resizeObserver.observe(chartContainer);
                
                // Store resize observer reference for cleanup
                chart._resizeObserver = resizeObserver;

                // Store reference to current chart
                currentChart = chart;

                // Add tooltip for OHLC values
                const tooltip = document.getElementById('ohlcTooltip');
                chart.subscribeCrosshairMove(param => {
                    // Simple check
                    if (!chart || isLineChartActive) {
                        return;
                    }
                    
                    if (param.point === undefined || !param.time || param.point.x < 0 || param.point.x > chartContainer.clientWidth || param.point.y < 0 || param.point.y > chartContainer.clientHeight) {
                        tooltip.style.display = 'none';
                        // Don't hide MACD tooltip when hiding main tooltip
                        return;
                    }

                    const data = param.seriesData.get(candlestickSeries);
                    if (data) {
                        const time = new Date(data.time * 1000);
                        const timeString = time.toLocaleTimeString('en-IN', { 
                            hour: '2-digit', 
                            minute: '2-digit', 
                            second: '2-digit',
                            hour12: true 
                        });
                        
                        // Update tooltip content
                        document.getElementById('tooltipTime').textContent = timeString;
                        document.getElementById('tooltipOpen').textContent = `₹${data.open.toFixed(2)}`;
                        document.getElementById('tooltipHigh').textContent = `₹${data.high.toFixed(2)}`;
                        document.getElementById('tooltipLow').textContent = `₹${data.low.toFixed(2)}`;
                        document.getElementById('tooltipClose').textContent = `₹${data.close.toFixed(2)}`;
                        
                        // Calculate and display VWAP for this specific bar
                        if (selectedIndicators.has('vwap')) {
                            try {
                                // Find the index of this data point in the original chart data
                                const dataIndex = candlestickData.findIndex(item => 
                                    item.time === data.time
                                );
                                
                                if (dataIndex !== -1) {
                                    // Calculate VWAP up to this point
                                    const vwapValues = calculateVWAP(candlestickData.slice(0, dataIndex + 1));
                                    const currentVWAP = vwapValues[vwapValues.length - 1];
                                    
                                    if (currentVWAP !== undefined) {
                                        document.getElementById('tooltipVWAP').textContent = `₹${currentVWAP.toFixed(2)}`;
                                        document.getElementById('tooltipVWAP').parentElement.style.display = 'block';
                                    } else {
                                        document.getElementById('tooltipVWAP').parentElement.style.display = 'none';
                                    }
                                } else {
                                    document.getElementById('tooltipVWAP').parentElement.style.display = 'none';
                                }
                            } catch (error) {
                                console.error('Error calculating VWAP for tooltip:', error);
                                document.getElementById('tooltipVWAP').parentElement.style.display = 'none';
                            }
                        } else {
                            // Hide VWAP row if not selected
                            document.getElementById('tooltipVWAP').parentElement.style.display = 'none';
                        }


                        // Calculate and display MACD values for this specific bar
                        if (selectedIndicators.has('macd')) {
                            try {
                                // Find the index of this data point in the original chart data
                                const dataIndex = candlestickData.findIndex(item => 
                                    item.time === data.time
                                );
                                
                                if (dataIndex !== -1) {
                                    // Use the same MACD calculation as the sub-chart for consistency
                                    // Calculate MACD for the full dataset (same as sub-chart)
                                    const macdData = calculateMACD(candlestickData);
                                    
                                    // MACD needs at least 26 data points to be reliable (same logic as RSI/EMA)
                                    const minDataPointsForMACD = 26;
                                    
                                    // Debug: Log timing information for tooltip
                                    if (dataIndex === minDataPointsForMACD) { // Log when crossing the threshold
                                        const startTime = new Date(candlestickData[0].time * 1000);
                                        const currentTime = new Date(data.time * 1000);
                                        const timeDiff = (currentTime - startTime) / (1000 * 60);
                                        console.log('=== TOOLTIP MACD DEBUG ===');
                                        console.log('Data start time:', startTime.toLocaleTimeString());
                                        console.log('Current hover time:', currentTime.toLocaleTimeString());
                                        console.log('Time elapsed:', timeDiff.toFixed(1), 'minutes');
                                        console.log('Data index:', dataIndex, '(data point check - same as RSI/EMA)');
                                    }
                                    
                                    if (macdData.macdLine.length > 0 && dataIndex < macdData.macdLine.length && dataIndex >= minDataPointsForMACD) {
                                        const currentMACD = macdData.macdLine[dataIndex];
                                        const currentSignal = macdData.signalLine[dataIndex];
                                        const currentHistogram = macdData.histogram[dataIndex];
                                        
                                        if (currentMACD !== undefined && !isNaN(currentMACD)) {
                                            document.getElementById('tooltipMACD').textContent = currentMACD.toFixed(4);
                                            document.getElementById('tooltipSignal').textContent = currentSignal.toFixed(4);
                                            document.getElementById('tooltipHistogram').textContent = currentHistogram.toFixed(4);
                                            
                                            // Show MACD rows
                                            document.getElementById('tooltipMACD').parentElement.style.display = 'block';
                                            document.getElementById('tooltipSignal').parentElement.style.display = 'block';
                                            document.getElementById('tooltipHistogram').parentElement.style.display = 'block';
                                        } else {
                                            // Hide MACD rows if values are undefined
                                            document.getElementById('tooltipMACD').parentElement.style.display = 'none';
                                            document.getElementById('tooltipSignal').parentElement.style.display = 'none';
                                            document.getElementById('tooltipHistogram').parentElement.style.display = 'none';
                                        }

                                    } else {
                                        // Hide MACD rows if no data, index out of bounds, or before minimum periods
                                        document.getElementById('tooltipMACD').parentElement.style.display = 'none';
                                        document.getElementById('tooltipSignal').parentElement.style.display = 'none';
                                        document.getElementById('tooltipHistogram').parentElement.style.display = 'none';
                                    }
                                } else {
                                    // Hide MACD rows if index not found
                                    document.getElementById('tooltipMACD').parentElement.style.display = 'none';
                                    document.getElementById('tooltipSignal').parentElement.style.display = 'none';
                                    document.getElementById('tooltipHistogram').parentElement.style.display = 'none';
                                }
                            } catch (error) {
                                console.error('Error calculating MACD for tooltip:', error);
                                // Hide MACD rows on error
                                document.getElementById('tooltipMACD').parentElement.style.display = 'none';
                                document.getElementById('tooltipSignal').parentElement.style.display = 'none';
                                document.getElementById('tooltipHistogram').parentElement.style.display = 'none';
                            }
                        } else {
                            // Hide MACD rows if not selected
                            document.getElementById('tooltipMACD').parentElement.style.display = 'none';
                            document.getElementById('tooltipSignal').parentElement.style.display = 'none';
                            document.getElementById('tooltipHistogram').parentElement.style.display = 'none';
                        }

                        // Calculate and display RSI values for this specific bar (moved outside MACD block)
                                        if (selectedIndicators.has('rsi')) {
                                            try {
                                                // Find the index of this data point in the original chart data
                                                const dataIndex = candlestickData.findIndex(item => 
                                                    item.time === data.time
                                                );
                                                
                                                if (dataIndex !== -1) {
                                                    // Calculate RSI up to this point
                                                    const rsiData = calculateRSI(candlestickData.slice(0, dataIndex + 1));
                                                    
                                                    if (rsiData.length > 0) {
                                                        const currentRSI = rsiData[rsiData.length - 1];
                                                        
                                                        if (currentRSI !== undefined) {
                                                            document.getElementById('tooltipRSI').textContent = currentRSI.toFixed(2);
                                                            
                                                            // Show RSI row
                                                            document.getElementById('tooltipRSI').parentElement.style.display = 'block';
                                                        } else {
                                                            // Hide RSI row if value is undefined
                                                            document.getElementById('tooltipRSI').parentElement.style.display = 'none';
                                                        }
                                                    } else {
                                                        // Hide RSI row if no data
                                                        document.getElementById('tooltipRSI').parentElement.style.display = 'none';
                                                    }
                                                } else {
                                                    // Hide RSI row if data point not found
                                                    document.getElementById('tooltipRSI').parentElement.style.display = 'none';
                                                }
                                            } catch (error) {
                                                console.error('Error calculating RSI for tooltip:', error);
                                                // Hide RSI row on error
                                                document.getElementById('tooltipRSI').parentElement.style.display = 'none';
                                            }
                                        } else {
                                            // Hide RSI row if RSI not selected
                                            document.getElementById('rsiRow').style.display = 'none';
                                        }
                                        
                        // Calculate and display EMA 20 for this specific bar (moved outside MACD block)
                                        if (selectedIndicators.has('ema_20')) {
                            try {
                                // Find the index of this data point in the original chart data
                                const dataIndex = candlestickData.findIndex(item => 
                                    item.time === data.time
                                );
                                
                                if (dataIndex !== -1) {
                                    // Calculate EMA 20 up to this point
                                    const emaData = calculateEMA(candlestickData.slice(0, dataIndex + 1), 20);
                                                
                                                if (emaData.length > 0) {
                                                    const currentEMA = emaData[emaData.length - 1];
                                                    
                                                    if (currentEMA !== undefined && !isNaN(currentEMA)) {
                                            document.getElementById('tooltipEMA20').textContent = `₹${currentEMA.toFixed(2)}`;
                                                        document.getElementById('ema20Row').style.display = 'block';
                                                        console.log('EMA 20 tooltip updated:', currentEMA.toFixed(2));
                                                    } else {
                                                        document.getElementById('ema20Row').style.display = 'none';
                                                    }
                                                } else {
                                        document.getElementById('ema20Row').style.display = 'none';
                                    }
                                } else {
                                                    document.getElementById('ema20Row').style.display = 'none';
                                                }
                                            } catch (error) {
                                console.error('Error calculating EMA 20 for tooltip:', error);
                                                document.getElementById('ema20Row').style.display = 'none';
                                            }
                                        } else {
                            // Hide EMA 20 row if not selected
                                            document.getElementById('ema20Row').style.display = 'none';
                                        }

                        // Calculate and display EMA 50 for this specific bar
                        if (selectedIndicators.has('ema_50')) {
                            try {
                                // Find the index of this data point in the original chart data
                                const dataIndex = candlestickData.findIndex(item => 
                                    item.time === data.time
                                );
                                
                                if (dataIndex !== -1) {
                                    // Calculate EMA 50 up to this point
                                    const ema50Data = calculateEMA(candlestickData.slice(0, dataIndex + 1), 50);
                                    
                                    if (ema50Data.length > 0) {
                                        const currentEMA50 = ema50Data[ema50Data.length - 1];
                                        
                                        if (currentEMA50 !== undefined && !isNaN(currentEMA50)) {
                                            document.getElementById('tooltipEMA50').textContent = `₹${currentEMA50.toFixed(2)}`;
                                            document.getElementById('ema50Row').style.display = 'block';
                                            console.log('EMA 50 tooltip updated:', currentEMA50.toFixed(2));
                                    } else {
                                            document.getElementById('ema50Row').style.display = 'none';
                                    }
                                } else {
                                        document.getElementById('ema50Row').style.display = 'none';
                                    }
                                } else {
                                    document.getElementById('ema50Row').style.display = 'none';
                                }
                            } catch (error) {
                                console.error('Error calculating EMA 50 for tooltip:', error);
                                document.getElementById('ema50Row').style.display = 'none';
                            }
                        } else {
                            // Hide EMA 50 row if not selected
                            document.getElementById('ema50Row').style.display = 'none';
                        }
                        
                        // Calculate and display EMA 100 for this specific bar
                        if (selectedIndicators.has('ema_100')) {
                            try {
                                // Find the index of this data point in the original chart data
                                const dataIndex = candlestickData.findIndex(item => 
                                    item.time === data.time
                                );
                                
                                if (dataIndex !== -1) {
                                    // Calculate EMA 100 up to this point
                                    const ema100Data = calculateEMA(candlestickData.slice(0, dataIndex + 1), 100);
                                    
                                    if (ema100Data.length > 0) {
                                        const currentEMA100 = ema100Data[ema100Data.length - 1];
                                        
                                        if (currentEMA100 !== undefined && !isNaN(currentEMA100)) {
                                            document.getElementById('tooltipEMA100').textContent = `₹${currentEMA100.toFixed(2)}`;
                                            document.getElementById('ema100Row').style.display = 'block';
                                            console.log('EMA 100 tooltip updated:', currentEMA100.toFixed(2));
                                        } else {
                                            document.getElementById('ema100Row').style.display = 'none';
                                        }
                                    } else {
                                        document.getElementById('ema100Row').style.display = 'none';
                                    }
                                } else {
                                    document.getElementById('ema100Row').style.display = 'none';
                                }
                            } catch (error) {
                                console.error('Error calculating EMA 100 for tooltip:', error);
                                document.getElementById('ema100Row').style.display = 'none';
                            }
                        } else {
                            // Hide EMA 100 row if not selected
                            document.getElementById('ema100Row').style.display = 'none';
                        }
                        
                        // Calculate and display EMA 200 for this specific bar
                        if (selectedIndicators.has('ema_200')) {
                            try {
                                // Find the index of this data point in the original chart data
                                const dataIndex = candlestickData.findIndex(item => 
                                    item.time === data.time
                                );
                                
                                if (dataIndex !== -1) {
                                    // Calculate EMA 200 up to this point
                                    const ema200Data = calculateEMA(candlestickData.slice(0, dataIndex + 1), 200);
                                    
                                    if (ema200Data.length > 0) {
                                        const currentEMA200 = ema200Data[ema200Data.length - 1];
                                        
                                        if (currentEMA200 !== undefined && !isNaN(currentEMA200)) {
                                            document.getElementById('tooltipEMA200').textContent = `₹${currentEMA200.toFixed(2)}`;
                                            document.getElementById('ema200Row').style.display = 'block';
                                            console.log('EMA 200 tooltip updated:', currentEMA200.toFixed(2));
                                        } else {
                                            document.getElementById('ema200Row').style.display = 'none';
                                        }
                                    } else {
                                        document.getElementById('ema200Row').style.display = 'none';
                                    }
                                } else {
                                    document.getElementById('ema200Row').style.display = 'none';
                                }
                            } catch (error) {
                                console.error('Error calculating EMA 200 for tooltip:', error);
                                document.getElementById('ema200Row').style.display = 'none';
                            }
                        } else {
                            // Hide EMA 200 row if not selected
                            document.getElementById('ema200Row').style.display = 'none';
                        }
                        
                        // Position tooltip away from cursor for better visibility
                        const rect = chartContainer.getBoundingClientRect();
                        const tooltipWidth = 200; // Approximate tooltip width
                        const tooltipHeight = 180; // Increased height to accommodate MACD rows
                        
                        // Position tooltip to the right of cursor, or left if too close to edge
                        let leftPosition = param.point.x + 60;
                        if (leftPosition + tooltipWidth > chartContainer.clientWidth) {
                            leftPosition = param.point.x - tooltipWidth - 60;
                        }
                        
                        // Position tooltip above cursor, or below if too close to top
                        let topPosition = param.point.y - tooltipHeight - 50;
                        if (topPosition < 0) {
                            topPosition = param.point.y + 60;
                        }
                        
                        tooltip.style.left = Math.max(10, leftPosition) + 'px';
                        tooltip.style.top = Math.max(10, topPosition) + 'px';
                        tooltip.style.display = 'block';
                        
                        // Log tooltip information including VWAP and MACD if available
                        let tooltipLog = `${timeString} - O:₹${data.open.toFixed(2)} H:₹${data.high.toFixed(2)} L:₹${data.low.toFixed(2)} C:₹${data.close.toFixed(2)}`;
                        
                        // Check VWAP indicator for logging
                        if (selectedIndicators.has('vwap')) {
                            try {
                                const dataIndex = candlestickData.findIndex(item => item.time === data.time);
                                if (dataIndex !== -1) {
                                    const vwapValues = calculateVWAP(candlestickData.slice(0, dataIndex + 1));
                                    const currentVWAP = vwapValues[vwapValues.length - 1];
                                    if (currentVWAP !== undefined) {
                                        tooltipLog += ` VWAP:₹${currentVWAP.toFixed(2)}`;
                                    }
                                }
                            } catch (error) {
                                console.error('Error calculating VWAP for log:', error);
                            }
                        }

                        // Check MACD indicator for logging
                        if (selectedIndicators.has('macd')) {
                            try {
                                const dataIndex = candlestickData.findIndex(item => item.time === data.time);
                                if (dataIndex !== -1) {
                                    // Use the same MACD calculation as the main tooltip (full dataset)
                                    const macdData = calculateMACD(candlestickData);
                                    if (macdData.macdLine.length > 0 && dataIndex < macdData.macdLine.length) {
                                        const currentMACD = macdData.macdLine[dataIndex];
                                        const currentSignal = macdData.signalLine[dataIndex];
                                        const currentHistogram = macdData.histogram[dataIndex];
                                        
                                        if (currentMACD !== undefined) {
                                            tooltipLog += ` MACD:${currentMACD.toFixed(4)} Signal:${currentSignal.toFixed(4)} Hist:${currentHistogram.toFixed(4)}`;
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('Error calculating MACD for log:', error);
                            }
                        }
                        
                        console.log('OHLC Tooltip:', tooltipLog);
                    } else {
                        tooltip.style.display = 'none';
                    }
                });

                console.log('=== LIGHTWEIGHT CANDLESTICK CHART CREATED SUCCESSFULLY ===');
                
                // Reset the flag to allow future chart creation
                isCreatingChart = false;
            }

            // Function to create MACD panel
            async function createMACDPanel(candlestickData, macdData) {
                try {
                    console.log('Creating MACD panel...');
                    console.log('MACD Panel Data Validation:');
                    console.log('- Candlestick data length:', candlestickData.length);
                    console.log('- MACD data:', macdData ? 'Available' : 'Insufficient data (null)');
                    if (macdData) {
                        console.log('- MACD data length:', macdData.macdLine.length);
                    }
                    console.log('- First candlestick time:', candlestickData.length > 0 ? new Date(candlestickData[0].time * 1000).toLocaleDateString() : 'No data');
                    console.log('- Last candlestick time:', candlestickData.length > 0 ? new Date(candlestickData[candlestickData.length - 1].time * 1000).toLocaleDateString() : 'No data');
                    
                    // Show MACD panel
                    const macdPanel = document.getElementById('macdPanel');
                    if (macdPanel) {
                        macdPanel.style.display = 'block';
                        
                        // Add title
                        if (!macdPanel.querySelector('h3')) {
                            const title = document.createElement('h3');
                            title.textContent = 'MACD (12, 26, 9)';
                            macdPanel.insertBefore(title, macdPanel.firstChild);
                        }
                    }
                    
                    // Create MACD chart
                    const macdChartContainer = document.getElementById('macdChart');
                    if (!macdChartContainer) {
                        console.error('MACD chart container not found');
                        return;
                    }
                    
                    // Clear existing chart and dispose any existing chart instance
                    if (window.macdChartInstance) {
                        try {
                            // Check if chart is still valid before disposing
                            if (window.macdChartInstance && typeof window.macdChartInstance.remove === 'function') {
                                window.macdChartInstance.remove();
                                console.log('MACD chart disposed successfully');
                            }
                        } catch (e) {
                            console.log('Chart disposal error (chart may already be disposed):', e.message);
                        } finally {
                            window.macdChartInstance = null;
                        }
                    }
                    
                    // Clear container completely
                    macdChartContainer.innerHTML = '';
                    
                    // Force a small delay to ensure cleanup is complete
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    // Check if we have enough data for MACD (need at least 26 data points) OR if macdData is null
                    if (candlestickData.length < 26 || macdData === null) {
                        console.log('Insufficient data for MACD chart:', candlestickData.length, 'data points (need 26)');
                        console.log('Showing insufficient data message for MACD panel');
                        
                        // Ensure MACD panel is visible to show the message
                        if (macdPanel) {
                            macdPanel.style.display = 'block';
                        }
                        
                        macdChartContainer.innerHTML = `
                            <div style="
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                height: 200px;
                                color: #ff6b6b;
                                font-size: 16px;
                                font-weight: 600;
                                text-align: center;
                                background: #0a0a0a;
                                border: 1px solid #ff6b6b;
                                border-radius: 8px;
                            ">
                                <div>
                                    <div style="margin-bottom: 8px;">⚠️ MACD Insufficient Data</div>
                                    <div style="font-size: 14px; color: #cccccc;">
                                        Need at least 26 data points for MACD calculation<br>
                                        Current data points: ${candlestickData.length}<br>
                                        <span style="color: #00ff88; font-size: 12px;">Other indicators are still available</span>
                                    </div>
                                </div>
                            </div>
                        `;
                        // Don't return here - let other indicators continue to work
                        // Just skip the MACD chart creation
                        console.log('MACD chart creation skipped due to insufficient data. Other indicators will continue to work.');
                        return;
                    }
                    
                    // Wait a bit for the container to be ready
                    setTimeout(() => {
                        // Check if we're switching chart types or line chart is active
                        if (isSwitchingChartType || isLineChartActive) {
                            console.log('Skipping MACD chart creation - chart switching in progress or line chart active');
                            return;
                        }
                        try {
                            // Create MACD chart using LightweightCharts
                            if (typeof LightweightCharts !== 'undefined') {
                                console.log('Creating MACD chart with LightweightCharts...');
                                
                                const macdChart = LightweightCharts.createChart(macdChartContainer, {
                                    width: macdChartContainer.clientWidth || 800,
                                    height: 200,
                                    layout: {
                                        background: { color: '#0a0a0a' },
                                        textColor: '#cccccc',
                                        fontFamily: 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif',
                                    },
                                    grid: {
                                        vertLines: { color: '#333333', alpha: 0.15, style: 1 },
                                        horzLines: { color: '#333333', alpha: 0.15, style: 1 },
                                    },
                                    crosshair: {
                                        mode: LightweightCharts.CrosshairMode.Normal,
                                        vertLine: {
                                            color: '#00aaff',
                                            width: 1,
                                            style: 3,
                                            labelBackgroundColor: '#00aaff',
                                            labelVisible: false,
                                        },
                                        horzLine: {
                                            color: '#00aaff',
                                            width: 1,
                                            style: 3,
                                            labelBackgroundColor: '#00aaff',
                                            labelVisible: false,
                                        },
                                    },
                                    rightPriceScale: {
                                        borderColor: '#333333',
                                        textColor: '#cccccc',
                                        scaleMargins: {
                                            top: 0.1,
                                            bottom: 0.1,
                                        },
                                        // MACD-specific price scale settings
                                        autoScale: true,
                                        autoScaleInfoProvider: () => ({
                                            priceRange: null,
                                            margins: null,
                                        }),
                                    },
                                    timeScale: {
                                        borderColor: '#333333',
                                        textColor: '#cccccc',
                                        timeVisible: true,
                                        secondsVisible: false,
                                        rightOffset: 12,
                                        barSpacing: 6,
                                        minBarSpacing: 3,
                                        borderVisible: true,
                                        fixLeftEdge: true,
                                        fixRightEdge: true,
                                        // MACD-specific time scale settings
                                        visible: true,
                                        tickMarkFormatter: (time, tickMarkType, locale) => {
                                            const date = new Date(time * 1000);
                                            return date.toLocaleTimeString('en-IN', {
                                                hour: '2-digit',
                                                minute: '2-digit',
                                                hour12: true
                                            });
                                        },
                                    },
                                    leftPriceScale: {
                                        visible: false,
                                    },
                                    watermark: {
                                        visible: false,
                                    },
                                });
                                
                                // Store chart instance for proper disposal
                                window.macdChartInstance = macdChart;
                                
                                console.log('MACD chart created, adding series...');
                                
                                // Check if chart is disposed before adding series
                                if (!macdChart || macdChart._disposed) {
                                    console.log('MACD chart disposed, skipping series creation');
                                    return;
                                }
                                
                                // Add MACD line series
                                const macdSeries = macdChart.addLineSeries({
                                    color: '#ff4444',
                                    lineWidth: 2,
                                    title: 'MACD',
                                    priceLineVisible: false,
                                    lastValueVisible: false,
                                });
                                
                                // Check if chart is still valid before adding signal series
                                if (!macdChart || macdChart._disposed) {
                                    console.log('MACD chart disposed, skipping signal series creation');
                                    return;
                                }
                                
                                // Add Signal line series
                                const signalSeries = macdChart.addLineSeries({
                                    color: '#00ff88',
                                    lineWidth: 2,
                                    title: 'Signal',
                                    priceLineVisible: false,
                                    lastValueVisible: false,
                                });
                                
                                // Add Histogram series
                                const histogramSeries = macdChart.addHistogramSeries({
                                    color: '#0088ff',
                                    priceFormat: {
                                        type: 'price',
                                        precision: 4,
                                        minMove: 0.0001,
                                    },
                                });
                                
                                // Prepare data for MACD chart with validation
                                console.log('MACD data validation:', {
                                    macdLine: macdData.macdLine.length,
                                    signalLine: macdData.signalLine.length,
                                    histogram: macdData.histogram.length,
                                    sampleMACD: macdData.macdLine.slice(0, 3),
                                    sampleSignal: macdData.signalLine.slice(0, 3),
                                    sampleHistogram: macdData.histogram.slice(0, 3)
                                });
                                
                                // Prepare MACD data (same simple logic as RSI)
                                const macdChartData = [];
                                const signalChartData = [];
                                const histogramData = [];
                                
                                const period = 26; // MACD slow period
                                
                                console.log('MACD Data Alignment Debug:');
                                console.log('Candlestick data length:', candlestickData.length);
                                console.log('MACD data length:', macdData.macdLine.length);
                                
                                // Map MACD data to candlestick times (same as RSI)
                                // MACD calculation starts after the period (26 values), so MACD[0] corresponds to candlestick[26]
                                for (let i = 0; i < macdData.macdLine.length; i++) {
                                    const candlestickIndex = i + period; // MACD starts after the period
                                    if (candlestickIndex < candlestickData.length) {
                                        const macdValue = macdData.macdLine[i];
                                        const signalValue = macdData.signalLine[i];
                                        const histogramValue = macdData.histogram[i];
                                        
                                        // Only add if values are valid
                                        if (!isNaN(macdValue) && !isNaN(signalValue) && !isNaN(histogramValue)) {
                                            macdChartData.push({
                                                time: candlestickData[candlestickIndex].time,
                                                value: macdValue
                                            });
                                            
                                            signalChartData.push({
                                                time: candlestickData[candlestickIndex].time,
                                                value: signalValue
                                            });
                                            
                                            histogramData.push({
                                                time: candlestickData[candlestickIndex].time,
                                                value: histogramValue,
                                                color: histogramValue >= 0 ? '#00ff88' : '#ff4444'
                                            });
                                        }
                                    }
                                }
                                
                                console.log('MACD chart data points created:', macdChartData.length);
                                if (macdChartData.length > 0) {
                                    console.log('First MACD point time:', new Date(macdChartData[0].time * 1000).toLocaleTimeString());
                                    console.log('Last MACD point time:', new Date(macdChartData[macdChartData.length - 1].time * 1000).toLocaleTimeString());
                                }
                                
                                // Only proceed if we have valid data
                                if (macdChartData.length === 0) {
                                    console.error('No valid MACD data points found');
                                    return;
                                }
                                
                                console.log('Setting MACD data to series...');
                                console.log('MACD chart data points:', macdChartData.length);
                                console.log('First MACD data point:', macdChartData[0]);
                                console.log('Last MACD data point:', macdChartData[macdChartData.length - 1]);
                                
                                // Set data to series
                                macdSeries.setData(macdChartData);
                                signalSeries.setData(signalChartData);
                                histogramSeries.setData(histogramData);
                                
                                // Check if chart is still valid before adding zero line
                                if (!macdChart || macdChart._disposed) {
                                    console.log('MACD chart disposed, skipping zero line creation');
                                    return;
                                }
                                
                                // Add zero line
                                const zeroLine = macdChart.addLineSeries({
                                    color: '#666666',
                                    lineWidth: 1,
                                    lineStyle: 2, // Dashed
                                    priceLineVisible: false,
                                    lastValueVisible: false,
                                });
                                
                                // Zero line should only cover the MACD data range
                                const zeroData = macdChartData.map(point => ({
                                    time: point.time,
                                    value: 0
                                }));
                                zeroLine.setData(zeroData);
                                
                                // Set time scale to match the actual MACD data range (no empty spaces)
                                if (macdChartData.length > 0) {
                                    const startTime = macdChartData[0].time;
                                    const endTime = macdChartData[macdChartData.length - 1].time;
                                    
                                    console.log('MACD Data Range Debug:');
                                    console.log('First candlestick time:', new Date(candlestickData[0].time * 1000).toLocaleTimeString());
                                    console.log('MACD start time:', new Date(startTime * 1000).toLocaleTimeString());
                                    console.log('MACD end time:', new Date(endTime * 1000).toLocaleTimeString());
                                    console.log('Gap from 9:15 to MACD start:', (startTime - candlestickData[0].time) / 60, 'minutes');
                                    
                                    // Set the exact visible range to eliminate gaps
                                    setTimeout(() => {
                                        try {
                                            // Check if line chart is active or chart switching is in progress
                                            if (isLineChartActive || isSwitchingChartType) {
                                                console.log('Skipping MACD time scale - line chart active or switching');
                                                return;
                                            }
                                            console.log('Applying MACD time scale...');
                                            if (macdChart && !macdChart._disposed && typeof macdChart.timeScale === 'function') {
                                                macdChart.timeScale().setVisibleRange({
                                                    from: startTime,
                                                    to: endTime
                                                });
                                                console.log('MACD time scale applied');
                                            }
                                        } catch (error) {
                                            console.log('Error setting MACD time scale:', error);
                                        }
                                    }, 200);
                                }
                                
                                console.log('MACD panel created successfully');
                                
                                // Simple MACD tooltip with mouse tracking
                                let mouseX = 0, mouseY = 0;
                                
                                // Track mouse position
                                macdChartContainer.addEventListener('mousemove', (e) => {
                                    mouseX = e.clientX;
                                    mouseY = e.clientY;
                                });
                                
                                macdChart.subscribeCrosshairMove(param => {
                                    // Check if chart is disposed before proceeding
                                    if (!macdChart || macdChart._disposed) {
                                        return;
                                    }
                                    
                                    if (param.time !== undefined && param.point) {
                                        const timestamp = param.time;
                                        
                                        // Find the corresponding candlestick data index (same logic as main chart)
                                        const candlestickIndex = candlestickData.findIndex(item => item.time === timestamp);
                                        
                                        if (candlestickIndex !== -1) {
                                            // Use the same MACD calculation as main chart
                                            const macdValue = macdData.macdLine[candlestickIndex];
                                            const signalValue = macdData.signalLine[candlestickIndex];
                                            const histogramValue = macdData.histogram[candlestickIndex];
                                            
                                            // Only show tooltip if values are valid (same logic as main chart)
                                            if (macdValue !== undefined && !isNaN(macdValue) && candlestickIndex >= 26) {
                                            // Create simple tooltip
                                            let tooltip = document.getElementById('macdTooltip');
                                            if (!tooltip) {
                                                tooltip = document.createElement('div');
                                                tooltip.id = 'macdTooltip';
                                                tooltip.style.cssText = `
                                                    position: fixed;
                                                    background: black;
                                                    color: white;
                                                    padding: 10px;
                                                    border: 2px solid #00ccff;
                                                    border-radius: 5px;
                                                    font-size: 12px;
                                                    z-index: 9999;
                                                    pointer-events: none;
                                                `;
                                                document.body.appendChild(tooltip);
                                            }
                                            
                                            const date = new Date(timestamp * 1000);
                                            const timeString = date.toLocaleTimeString('en-IN', { 
                                                hour: '2-digit', 
                                                minute: '2-digit', 
                                                second: '2-digit',
                                                hour12: true 
                                            });
                                            
                                            tooltip.innerHTML = `
                                                <div><strong>${timeString}</strong></div>
                                                <div>MACD: ${macdValue.toFixed(4)}</div>
                                                <div>Signal: ${signalValue.toFixed(4)}</div>
                                                <div>Histogram: ${histogramValue.toFixed(4)}</div>
                                            `;
                                            
                                            // Use actual mouse coordinates with more distance
                                            tooltip.style.left = (mouseX + 20) + 'px';
                                            tooltip.style.top = (mouseY - 20) + 'px';
                                            tooltip.style.display = 'block';
                                            
                                            console.log('MACD Tooltip:', timeString, 'MACD:', macdValue.toFixed(4), 'Signal:', signalValue.toFixed(4), 'Histogram:', histogramValue.toFixed(4));
                                            } else {
                                                // Hide tooltip if values are not valid
                                                const tooltip = document.getElementById('macdTooltip');
                                                if (tooltip) {
                                                    tooltip.style.display = 'none';
                                                }
                                            }
                                        }
                                    } else {
                                        const tooltip = document.getElementById('macdTooltip');
                                        if (tooltip) {
                                            tooltip.style.display = 'none';
                                        }
                                    }
                                });
                                
                                // Store reference for potential updates
                                window.currentMACDChart = macdChart;
                                
                            } else {
                                console.error('LightweightCharts not available for MACD panel');
                            }
                        } catch (error) {
                            console.error('Error in delayed MACD chart creation:', error);
                        }
                    }, 200);
                    
                } catch (error) {
                    console.error('Error creating MACD panel:', error);
                }
            }

            // Function to create RSI panel
            function createRSIPanel(candlestickData, rsiData) {
                try {
                    console.log('Creating RSI panel...');
                    console.log('RSI Panel Data Validation:');
                    console.log('- Candlestick data length:', candlestickData.length);
                    console.log('- RSI data:', rsiData ? 'Available' : 'Insufficient data (null)');
                    if (rsiData) {
                        console.log('- RSI data length:', rsiData.length);
                    }
                    
                    // Show RSI panel
                    const rsiPanel = document.getElementById('rsiPanel');
                    if (rsiPanel) {
                        rsiPanel.style.display = 'block';
                        
                        // Check if we have enough data for RSI (need at least 14 data points) OR if rsiData is null
                        if (candlestickData.length < 14 || rsiData === null) {
                            console.log('Insufficient data for RSI panel:', candlestickData.length, 'data points (need 14)');
                            const rsiChartContainer = document.getElementById('rsiChart');
                            if (rsiChartContainer) {
                                rsiChartContainer.innerHTML = `
                                    <div style="
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        height: 200px;
                                        color: #ff6b6b;
                                        font-size: 16px;
                                        font-weight: 600;
                                        text-align: center;
                                        background: #0a0a0a;
                                        border: 1px solid #ff6b6b;
                                        border-radius: 8px;
                                    ">
                                        <div>
                                            <div style="margin-bottom: 8px;">⚠️ RSI Insufficient Data</div>
                                            <div style="font-size: 14px; color: #cccccc;">
                                                Need at least 14 data points for RSI calculation<br>
                                                Current data points: ${candlestickData.length}<br>
                                                <span style="color: #00ff88; font-size: 12px;">Other indicators are still available</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }
                            return;
                        }
                        
                        // Add title and explanation
                        if (!rsiPanel.querySelector('h3')) {
                            const title = document.createElement('h3');
                            title.textContent = 'RSI (14)';
                            title.style.color = '#00ff88';
                            title.style.marginBottom = '5px';
                            title.style.textAlign = 'center';
                            rsiPanel.insertBefore(title, rsiPanel.firstChild);
                            
                            // Add explanation for time discrepancy
                            const explanation = document.createElement('div');
                            explanation.style.cssText = `
                                font-size: 11px;
                                color: #888;
                                text-align: center;
                                margin-bottom: 10px;
                                padding: 5px;
                                background: rgba(0, 255, 136, 0.1);
                                border-radius: 5px;
                                border: 1px solid rgba(0, 255, 136, 0.2);
                            `;
                            explanation.innerHTML = 'ℹ️ RSI starts after 14-period calculation (requires 14 previous price changes)';
                            rsiPanel.insertBefore(explanation, rsiPanel.firstChild.nextSibling);
                        }
                    }
                    
                    // Create RSI chart
                    const rsiChartContainer = document.getElementById('rsiChart');
                    if (!rsiChartContainer) {
                        console.error('RSI chart container not found');
                        return;
                    }
                    
                    // Clear existing chart and dispose any existing chart instance
                    if (window.rsiChartInstance) {
                        try {
                            // Check if chart is still valid before disposing
                            if (window.rsiChartInstance && typeof window.rsiChartInstance.remove === 'function') {
                                window.rsiChartInstance.remove();
                                console.log('RSI chart disposed successfully');
                            }
                        } catch (e) {
                            console.log('RSI chart disposal error (chart may already be disposed):', e.message);
                        } finally {
                            window.rsiChartInstance = null;
                        }
                    }
                    rsiChartContainer.innerHTML = '';
                    
                    // Wait a bit for the container to be ready
                    setTimeout(() => {
                        // Check if we're switching chart types
                        if (isSwitchingChartType) {
                            console.log('Skipping RSI chart creation - chart switching in progress');
                            return;
                        }
                        try {
                            if (typeof LightweightCharts !== 'undefined') {
                                console.log('Creating RSI chart with LightweightCharts...');
                                
                                // Create RSI chart
                                const rsiChart = LightweightCharts.createChart(rsiChartContainer, {
                                    width: rsiChartContainer.clientWidth,
                                    height: 200,
                                    layout: {
                                        background: { color: '#1a1a1a' },
                                        textColor: '#cccccc',
                                    },
                                    grid: {
                                        vertLines: { color: '#444444', alpha: 0.1 },
                                        horzLines: { color: '#444444', alpha: 0.1 },
                                    },
                                    crosshair: {
                                        mode: LightweightCharts.CrosshairMode.Normal,
                                        vertLine: {
                                            color: '#00aaff',
                                            width: 1,
                                            style: 3,
                                            labelBackgroundColor: '#00aaff',
                                            labelVisible: false,
                                        },
                                        horzLine: {
                                            color: '#00aaff',
                                            width: 1,
                                            style: 3,
                                            labelBackgroundColor: '#00aaff',
                                            labelVisible: false,
                                        },
                                    },
                                    rightPriceScale: {
                                        borderColor: '#444444',
                                        textColor: '#cccccc',
                                        scaleMargins: {
                                            top: 0.1,
                                            bottom: 0.1,
                                        },
                                    },
                                    timeScale: {
                                        borderColor: '#444444',
                                        textColor: '#cccccc',
                                        timeVisible: true,
                                        secondsVisible: false,
                                        rightOffset: 12,
                                        barSpacing: 3,
                                        minBarSpacing: 1,
                                        borderVisible: true,
                                        fixLeftEdge: true,
                                        fixRightEdge: true,
                                        tickMarkFormatter: (time) => {
                                            const date = new Date(time * 1000);
                                            const hours = date.getHours();
                                            const minutes = date.getMinutes();
                                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                                        },
                                        crosshairLabelVisible: true,
                                    },
                                    leftPriceScale: {
                                        visible: false,
                                    },
                                    watermark: {
                                        visible: false,
                                    },
                                });
                                
                                // Store RSI chart instance for proper disposal
                                window.rsiChartInstance = rsiChart;
                                
                                // Check if chart is disposed before adding series
                                if (!rsiChart || rsiChart._disposed) {
                                    console.log('RSI chart disposed, skipping series creation');
                                    return;
                                }
                                
                                // Add RSI line series
                                const rsiSeries = rsiChart.addLineSeries({
                                    color: '#00ff88',
                                    lineWidth: 2,
                                    priceLineVisible: false,
                                    lastValueVisible: true,
                                });
                                
                                // Prepare RSI data (RSI starts from index 1, so we need to align properly)
                                const rsiChartData = [];
                                // RSI data length should be candlestickData.length - 1 (since we skip first point)
                                const period = 14; // RSI period
                                const expectedRSILength = candlestickData.length - period;
                                
                                console.log('RSI Data Alignment Debug:');
                                console.log('Candlestick data length:', candlestickData.length);
                                console.log('RSI data length:', rsiData.length);
                                console.log('Expected RSI length:', expectedRSILength);
                                console.log('First candlestick time:', new Date(candlestickData[0].time * 1000).toLocaleTimeString());
                                console.log('Last candlestick time:', new Date(candlestickData[candlestickData.length - 1].time * 1000).toLocaleTimeString());
                                
                                // Map RSI data to candlestick times
                                // RSI calculation starts after the period (14 values), so RSI[0] corresponds to candlestick[14]
                                for (let i = 0; i < rsiData.length; i++) {
                                    const candlestickIndex = i + period; // RSI starts after the period
                                    if (candlestickIndex < candlestickData.length) {
                                        rsiChartData.push({
                                            time: candlestickData[candlestickIndex].time,
                                            value: rsiData[i]
                                        });
                                    } else {
                                        console.warn(`RSI data point ${i} has no corresponding candlestick at index ${candlestickIndex}`);
                                    }
                                }
                                
                                // Debug: Show the mapping relationship
                                console.log('RSI Data Mapping Debug:');
                                console.log('RSI data points:', rsiData.length);
                                console.log('Candlestick data points:', candlestickData.length);
                                console.log('Expected RSI chart points:', Math.min(rsiData.length, candlestickData.length - period));
                                console.log('Actual RSI chart points created:', rsiChartData.length);
                                
                                console.log('RSI chart data points created:', rsiChartData.length);
                                if (rsiChartData.length > 0) {
                                    console.log('First RSI point time:', new Date(rsiChartData[0].time * 1000).toLocaleTimeString(), 'RSI value:', rsiChartData[0].value.toFixed(2));
                                    console.log('Last RSI point time:', new Date(rsiChartData[rsiChartData.length - 1].time * 1000).toLocaleTimeString(), 'RSI value:', rsiChartData[rsiChartData.length - 1].value.toFixed(2));
                                    
                                    // CRITICAL DEBUG: Compare with main chart times
                                    console.log('=== END TIME COMPARISON ===');
                                    console.log('Main chart last time:', new Date(candlestickData[candlestickData.length - 1].time * 1000).toLocaleTimeString());
                                    console.log('RSI chart last time:', new Date(rsiChartData[rsiChartData.length - 1].time * 1000).toLocaleTimeString());
                                    
                                    if (rsiChartData[rsiChartData.length - 1].time === candlestickData[candlestickData.length - 1].time) {
                                        console.log('✅ RSI chart ends at the same time as main chart');
                                    } else {
                                        console.error('❌ RSI chart ends earlier than main chart!');
                                        console.error('This is the bug causing the 15:16 vs 15:29 issue!');
                                    }
                                    console.log('=============================');
                                }
                                
                                rsiSeries.setData(rsiChartData);
                                
                                // Check if chart is still valid before adding level lines
                                if (!rsiChart || rsiChart._disposed) {
                                    console.log('RSI chart disposed, skipping level lines');
                                    return;
                                }
                                
                                // Add RSI level lines
                                // Overbought line (70)
                                const overboughtLine = rsiChart.addLineSeries({
                                    color: '#ff4444',
                                    lineWidth: 1,
                                    lineStyle: 2, // Dashed
                                    priceLineVisible: false,
                                    lastValueVisible: false,
                                });
                                
                                // Create level lines that span the full RSI data range
                                const overboughtData = rsiChartData.map(point => ({
                                    time: point.time,
                                    value: 70
                                }));
                                overboughtLine.setData(overboughtData);
                                
                                // Check if chart is still valid before adding oversold line
                                if (!rsiChart || rsiChart._disposed) {
                                    console.log('RSI chart disposed, skipping oversold line');
                                    return;
                                }
                                
                                // Oversold line (30)
                                const oversoldLine = rsiChart.addLineSeries({
                                    color: '#ff4444',
                                    lineWidth: 1,
                                    lineStyle: 2, // Dashed
                                    priceLineVisible: false,
                                    lastValueVisible: false,
                                });
                                
                                const oversoldData = rsiChartData.map(point => ({
                                    time: point.time,
                                    value: 30
                                }));
                                oversoldLine.setData(oversoldData);
                                
                                // Check if chart is still valid before adding center line
                                if (!rsiChart || rsiChart._disposed) {
                                    console.log('RSI chart disposed, skipping center line');
                                    return;
                                }
                                
                                // Center line (50)
                                const centerLine = rsiChart.addLineSeries({
                                    color: '#666666',
                                    lineWidth: 1,
                                    lineStyle: 2, // Dashed
                                    priceLineVisible: false,
                                    lastValueVisible: false,
                                });
                                
                                const centerData = rsiChartData.map(point => ({
                                    time: point.time,
                                    value: 50
                                }));
                                centerLine.setData(centerData);
                                
                                console.log('RSI panel created successfully');
                                
                                // RSI tooltip with mouse tracking
                                let mouseX = 0, mouseY = 0;
                                
                                // Track mouse position
                                rsiChartContainer.addEventListener('mousemove', (e) => {
                                    mouseX = e.clientX;
                                    mouseY = e.clientY;
                                });
                                
                                rsiChart.subscribeCrosshairMove(param => {
                                    // Check if chart is disposed before proceeding
                                    if (!rsiChart || rsiChart._disposed) {
                                        return;
                                    }
                                    
                                    const tooltip = document.getElementById('rsiTooltip');
                                    if (!tooltip) {
                                        // Create RSI tooltip if it doesn't exist
                                        const newTooltip = document.createElement('div');
                                        newTooltip.id = 'rsiTooltip';
                                        newTooltip.style.cssText = `
                                            position: fixed;
                                            background: rgba(42, 42, 42, 0.95);
                                            border: 1px solid #00ff88;
                                            border-radius: 8px;
                                            padding: 12px;
                                            font-family: 'Courier New', monospace;
                                            font-size: 12px;
                                            color: #ffffff;
                                            z-index: 1000;
                                            backdrop-filter: blur(10px);
                                            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                                            pointer-events: none;
                                            display: none;
                                        `;
                                        document.body.appendChild(newTooltip);
                                    }
                                    
                                    if (param.time && param.seriesData && param.seriesData.size > 0) {
                                        const data = param.seriesData.get(rsiSeries);
                                        if (data) {
                                            const timestamp = param.time;
                                            const date = new Date(timestamp * 1000);
                                            const hours = date.getHours();
                                            const minutes = date.getMinutes();
                                            const seconds = date.getSeconds();
                                            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                                            
                                            const rsiValue = data.value;
                                            let rsiStatus = '';
                                            if (rsiValue > 70) rsiStatus = ' (Overbought)';
                                            else if (rsiValue < 30) rsiStatus = ' (Oversold)';
                                            else if (rsiValue > 50) rsiStatus = ' (Bullish)';
                                            else rsiStatus = ' (Bearish)';
                                            
                                            const tooltip = document.getElementById('rsiTooltip');
                                            tooltip.innerHTML = `
                                                <div><strong>${timeString}</strong></div>
                                                <div>RSI: ${rsiValue.toFixed(2)}${rsiStatus}</div>
                                            `;
                                            
                                            // Use actual mouse coordinates with more distance
                                            tooltip.style.left = (mouseX + 20) + 'px';
                                            tooltip.style.top = (mouseY - 20) + 'px';
                                            tooltip.style.display = 'block';
                                            
                                            console.log('RSI Tooltip:', timeString, 'RSI:', rsiValue.toFixed(2), rsiStatus);
                                        }
                                    } else {
                                        const tooltip = document.getElementById('rsiTooltip');
                                        if (tooltip) {
                                            tooltip.style.display = 'none';
                                        }
                                    }
                                });
                                
                                // Store reference for potential updates
                                window.currentRSIChart = rsiChart;
                                
                            } else {
                                console.error('LightweightCharts not available for RSI panel');
                            }
                        } catch (error) {
                            console.error('Error creating RSI chart:', error);
                        }
                    }, 200);
                } catch (error) {
                    console.error('Error in createRSIPanel:', error);
                }
            }

            function createChartJSLineChart(chartData, title) {
                console.log('Creating Chart.js line chart');
                
                // Destroy existing chart if it exists
                if (interactiveChart) {
                    interactiveChart.destroy();
                }

                // Hide sub-chart containers for line chart
                console.log('Hiding MACD/RSI containers for line chart...');
                isLineChartActive = true;
                
                const macdContainer = document.getElementById('macdChart');
                const rsiContainer = document.getElementById('rsiChart');
                
                if (macdContainer && macdContainer.parentElement) {
                    macdContainer.parentElement.style.display = 'none';
                    console.log('MACD container hidden');
                }
                
                if (rsiContainer && rsiContainer.parentElement) {
                    rsiContainer.parentElement.style.display = 'none';
                    console.log('RSI container hidden');
                }

                // Show line chart container, hide candlestick container
                document.querySelector('.interactive-chart-container').style.display = 'block';
                document.querySelector('.candlestick-chart-container').style.display = 'none';

                const ctx = document.getElementById('interactiveChart').getContext('2d');
                
                const labels = chartData.map(item => item.time);
                const closeData = chartData.map(item => item.close);
                const openData = chartData.map(item => item.open);
                const highData = chartData.map(item => item.high);
                const lowData = chartData.map(item => item.low);
                
                console.log('Chart labels:', labels);
                console.log('Chart data sample:', chartData.slice(0, 3));
                console.log('Close data range:', Math.min(...closeData), 'to', Math.max(...closeData));

                // Create line chart
                interactiveChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Straddle Close Price',
                                data: closeData,
                                borderColor: '#00ff88',
                                backgroundColor: 'rgba(0, 255, 136, 0.1)',
                                borderWidth: 3,
                                fill: false,
                                tension: 0.1,
                                pointRadius: 2,
                                pointHoverRadius: 5
                            },
                            {
                                label: 'Straddle Open Price',
                                data: openData,
                                borderColor: '#00ccff',
                                backgroundColor: 'rgba(0, 204, 255, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                tension: 0.1,
                                pointRadius: 1,
                                pointHoverRadius: 4
                            },
                            {
                                label: 'Straddle High',
                                data: highData,
                                borderColor: '#ff8800',
                                backgroundColor: 'rgba(255, 136, 0, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                tension: 0.1,
                                pointRadius: 1,
                                pointHoverRadius: 4
                            },
                            {
                                label: 'Straddle Low',
                                data: lowData,
                                borderColor: '#ff4444',
                                backgroundColor: 'rgba(255, 68, 68, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                tension: 0.1,
                                pointRadius: 1,
                                pointHoverRadius: 4
                            }
                        ]
                    },
                    options: getChartOptions(title, 'line')
                });

                console.log('Chart.js line chart created successfully');
            }

            function createChartJSCandlestickChart(chartData, title) {
                console.log('Creating professional LightweightCharts candlestick chart');
                
                // Check if LightweightCharts is available
                if (typeof LightweightCharts === 'undefined') {
                    console.error('LightweightCharts library not loaded!');
                    console.log('Falling back to Chart.js candlestick implementation...');
                    createChartJSFallbackCandlestickChart(chartData, title);
                    return;
                }
                
                console.log('LightweightCharts library is available');
                
                // Destroy existing chart if it exists
                if (interactiveChart) {
                    interactiveChart.destroy();
                }

                // Hide line chart container, show candlestick container
                document.querySelector('.interactive-chart-container').style.display = 'none';
                document.querySelector('.candlestick-chart-container').style.display = 'block';

                const chartContainer = document.getElementById('candlestickChart');
                if (!chartContainer) {
                    console.error('Candlestick chart container not found');
                    return;
                }
                
                console.log('Chart container found:', chartContainer);
                console.log('Container dimensions:', chartContainer.clientWidth, 'x', chartContainer.clientHeight);
                
                // Reset disposal flag - we're creating a new interactive chart
                isChartDisposed = false;
                
                // Create the professional chart
                console.log('Creating LightweightCharts chart...');
                let chart;
                try {
                    chart = LightweightCharts.createChart(chartContainer, {
                        width: chartContainer.clientWidth,
                        height: 400,
                        layout: {
                            background: { color: '#0a0a0a' },
                            textColor: '#cccccc',
                            fontFamily: 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif',
                        },
                        grid: {
                            vertLines: { color: '#333333', alpha: 0.15, style: 1 },
                            horzLines: { color: '#333333', alpha: 0.15, style: 1 },
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal,
                            vertLine: {
                                color: '#00ccff',
                                width: 2,
                                style: 3,
                                labelBackgroundColor: '#00ccff',
                                labelTextColor: '#ffffff',
                                labelVisible: false,
                            },
                            horzLine: {
                                color: '#00ccff',
                                width: 2,
                                style: 3,
                                labelBackgroundColor: '#00ccff',
                                labelTextColor: '#ffffff',
                                labelVisible: false,
                            },
                        },
                        rightPriceScale: {
                            borderColor: '#444444',
                            textColor: '#cccccc',
                        },
                        timeScale: {
                            borderColor: '#444444',
                            textColor: '#cccccc',
                            timeVisible: true,
                            secondsVisible: false,
                            // Professional time formatting
                            tickMarkFormatter: (time) => {
                                const date = new Date(time * 1000);
                                const hours = date.getHours().toString().padStart(2, '0');
                                const minutes = date.getMinutes().toString().padStart(2, '0');
                                
                                // Show date for first tick and time for others
                                if (time === candlestickData[0].time) {
                                    const day = date.getDate();
                                    const month = date.toLocaleDateString('en-US', { month: 'short' });
                                    const year = date.getFullYear().toString().slice(-2);
                                    return `${day} ${month} '${year}`;
                                }
                                return `${hours}:${minutes}`;
                            },
                            // Better time intervals
                            rightOffset: 12,
                            barSpacing: 3,
                            minBarSpacing: 1,
                            // Professional appearance
                            borderVisible: true,
                            fixLeftEdge: true,
                            fixRightEdge: true,
                            // Enable zoom and pan
                            allowVisibleLogicalRangeChange: true,
                            autoScale: true,
                        },
                        // Remove any extra padding and margins for cleaner look
                        leftPriceScale: {
                            visible: false,
                        },
                        // Professional chart appearance
                        watermark: {
                            visible: false,
                        },
                    });

                    // Create candlestick series with professional styling
                    const candlestickSeries = chart.addCandlestickSeries({
                        upColor: '#00ff88',
                        downColor: '#ff4444',
                        borderDownColor: '#ff4444',
                        borderUpColor: '#00ff88',
                        wickDownColor: '#ff4444',
                        wickUpColor: '#00ff88',
                        // Professional appearance
                        borderVisible: false,
                        wickThickness: 1,
                    });

                    // Add volume series for professional appearance
                    const volumeSeries = chart.addHistogramSeries({
                        color: '#00ccff',
                        priceFormat: {
                            type: 'volume',
                        },
                        priceScaleId: '', // Set to overlay
                        scaleMargins: {
                            top: 0.8, // Position at bottom
                            bottom: 0,
                        },
                    });

                    // Set volume data (using close price as volume for demonstration)
                    const volumeData = candlestickData.map(candle => ({
                        time: candle.time,
                        value: Math.abs(candle.close - candle.open) * 100, // Simulated volume
                        color: candle.close >= candle.open ? '#00ff88' : '#ff4444'
                    }));
                    volumeSeries.setData(volumeData);

                    // Prepare data for the chart with proper timestamps
                    const candlestickData = chartData.map((candle, index) => {
                        // Handle different time formats from different timeframes
                        let timeString = candle.time;
                        console.log(`Processing time: "${timeString}" for candle ${index}`);
                        
                        let hours, minutes, seconds;
                        const timeParts = timeString.split(':');
                        
                        if (timeParts.length === 3) {
                            // Format: HH:MM:SS (1-minute data)
                            hours = parseInt(timeParts[0]);
                            minutes = parseInt(timeParts[1]);
                            seconds = parseInt(timeParts[2]);
                            console.log(`3-part time format: ${hours}:${minutes}:${seconds}`);
                        } else if (timeParts.length === 2) {
                            // Format: HH:MM (3-minute, 5-minute, etc. data)
                            hours = parseInt(timeParts[0]);
                            minutes = parseInt(timeParts[1]);
                            seconds = 0; // Set seconds to 0 for higher timeframes
                            console.log(`2-part time format: ${hours}:${minutes}:00`);
                        } else {
                            console.error(`Invalid time format: "${timeString}"`);
                            // Fallback: use index as time offset
                            const fallbackTime = new Date();
                            fallbackTime.setHours(9, 15 + index, 0, 0); // Start from 9:15 AM
                            return {
                                time: Math.floor(fallbackTime.getTime() / 1000),
                                open: candle.open,
                                high: candle.high,
                                low: candle.low,
                                close: candle.close
                            };
                        }
                        
                        // Get the selected date from the date dropdowns (straddle chart)
                        const yearSelect = document.getElementById('yearSelect');
                        const monthSelect = document.getElementById('monthSelect');
                        const daySelect = document.getElementById('daySelect');
                        
                        let selectedDate;
                        if (yearSelect && monthSelect && daySelect && 
                            yearSelect.value && monthSelect.value && daySelect.value) {
                            selectedDate = `${yearSelect.value}-${monthSelect.value}-${daySelect.value}`;
                        } else {
                            // Fallback: use current date if dropdowns not populated
                            const today = new Date();
                            selectedDate = today.toISOString().split('T')[0];
                            console.warn('Date dropdowns not populated, using current date:', selectedDate);
                        }
                        
                        // Create a timestamp for the selected date with the given time
                        const [year, month, day] = selectedDate.split('-');
                        const selectedDateTime = new Date(year, month - 1, day, hours, minutes, seconds, 0);
                        
                        return {
                            time: Math.floor(selectedDateTime.getTime() / 1000), // Unix timestamp
                            open: candle.open,
                            high: candle.high,
                            low: candle.low,
                            close: candle.close
                        };
                    });

                    // Set the data
                    candlestickSeries.setData(candlestickData);

                    // Handle window resize
                    const resizeObserver = new ResizeObserver(entries => {
                        if (entries.length === 0 || entries[0].target !== chartContainer) { return; }
                        // Check if line chart is active to prevent disposal errors
                        if (isLineChartActive) { return; }
                        const newRect = entries[0].contentRect;
                        chart.applyOptions({ height: newRect.height, width: newRect.width });
                    });

                    resizeObserver.observe(chartContainer);
                    
                    // Store resize observer reference for cleanup
                    chart._resizeObserver = resizeObserver;

                    // Store reference to current chart
                    interactiveChart = chart;



                    // Add professional tooltip for OHLC values
                    chart.subscribeCrosshairMove(param => {
                        // Simple check
                        if (!chart || isLineChartActive) {
                            return;
                        }
                        
                        const tooltip = document.getElementById('ohlcTooltip');
                        
                        if (param.time !== undefined) {
                            const data = param.seriesData.get(candlestickSeries);
                            if (data) {
                                // Find the corresponding candle data
                                const timestamp = param.time;
                                                        const candleIndex = candlestickData.findIndex(candle => candle.time === timestamp);
                        
                        if (candleIndex >= 0 && candleIndex < candlestickData.length) {
                            const candle = candlestickData[candleIndex];
                                    
                                    // Format time for tooltip (professional style)
                                    const date = new Date(timestamp * 1000);
                                    const day = date.getDate();
                                    const month = date.toLocaleDateString('en-US', { month: 'short' });
                                    const year = date.getFullYear().toString().slice(-2);
                                    const formattedTime = `${day} ${month} '${year} ${date.toLocaleTimeString('en-US', {
                                        hour12: false,
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit'
                                    })}`;
                                    
                                    // Update tooltip content
                                    document.getElementById('tooltipTime').textContent = formattedTime;
                                    document.getElementById('tooltipOpen').textContent = candle.open.toFixed(2);
                                    document.getElementById('tooltipHigh').textContent = candle.high.toFixed(2);
                                    document.getElementById('tooltipLow').textContent = candle.low.toFixed(2);
                                    document.getElementById('tooltipClose').textContent = candle.close.toFixed(2);
                                    
                                    // Show tooltip
                                    tooltip.style.display = 'block';
                                    
                                    // Position tooltip away from cursor for better visibility
                                    const rect = chartContainer.getBoundingClientRect();
                                    const tooltipWidth = 200; // Approximate tooltip width
                                    const tooltipHeight = 120; // Approximate tooltip height
                                    
                                    // Position tooltip to the right of cursor, or left if too close to edge
                                    let leftPosition = param.point.x + 60;
                                    if (leftPosition + tooltipWidth > chartContainer.clientWidth) {
                                        leftPosition = param.point.x - tooltipWidth - 60;
                                    }
                                    
                                    // Position tooltip above cursor, or below if too close to top
                                    let topPosition = param.point.y - tooltipHeight - 50;
                                    if (topPosition < 0) {
                                        topPosition = param.point.y + 60;
                                    }
                                    
                                    const x = leftPosition + rect.left;
                                    const y = topPosition + rect.top;
                                    
                                    tooltip.style.left = Math.max(rect.left + 10, x) + 'px';
                                    tooltip.style.top = Math.max(rect.top + 10, y) + 'px';
                                }
                            }
                        } else {
                            // Hide tooltip when not hovering
                            tooltip.style.display = 'none';
                        }
                    });

                    console.log('Professional LightweightCharts candlestick chart created successfully');
                    
                } catch (error) {
                    console.error('Error creating LightweightCharts chart:', error);
                    console.log('Falling back to Chart.js implementation...');
                    createChartJSFallbackCandlestickChart(chartData, title);
                }
            }
            
            // Fallback Chart.js candlestick implementation
            function createChartJSFallbackCandlestickChart(chartData, title) {
                console.log('Creating fallback Chart.js candlestick chart');
                
                // Destroy existing chart if it exists
                if (interactiveChart) {
                    interactiveChart.destroy();
                }

                // Show line chart container, hide candlestick container
                document.querySelector('.interactive-chart-container').style.display = 'block';
                document.querySelector('.candlestick-chart-container').style.display = 'none';

                const ctx = document.getElementById('interactiveChart').getContext('2d');
                
                // Use the EXACT same data structure as the working line chart
                const labels = chartData.map(item => item.time);
                const openData = chartData.map(item => Number(item.open));
                const highData = chartData.map(item => Number(item.high));
                const lowData = chartData.map(item => Number(item.low));
                const closeData = chartData.map(item => Number(item.close));
                
                // Store data globally for tooltip access
                window.currentCandlestickData = {
                    labels: labels,
                    openData: openData,
                    highData: highData,
                    lowData: lowData,
                    closeData: closeData
                };
                
                // Create the chart with Chart.js - using the same data structure as line chart
                interactiveChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Straddle Candlesticks',
                            data: closeData,
                            backgroundColor: closeData.map((close, index) => 
                                close >= openData[index] ? '#00ff88' : '#ff4444'
                            ),
                            borderColor: closeData.map((close, index) => 
                                close >= openData[index] ? '#00cc66' : '#cc3333'
                            ),
                            borderWidth: 1,
                            barThickness: 'flex',
                            maxBarThickness: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: title,
                                color: '#ffffff',
                                font: {
                                    size: 18,
                                    weight: 'bold'
                                }
                            },
                            legend: {
                                display: false
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                                titleColor: '#ffffff',
                                bodyColor: '#cccccc',
                                borderColor: '#00ccff',
                                borderWidth: 2,
                                cornerRadius: 8,
                                callbacks: {
                                    title: function(context) {
                                        try {
                                            if (context && Array.isArray(context) && context.length > 0) {
                                                const tooltipItem = context[0];
                                                if (tooltipItem && typeof tooltipItem.dataIndex === 'number') {
                                                    const index = tooltipItem.dataIndex;
                                                    const timeLabel = window.currentCandlestickData.labels[index];
                                                    return `Time: ${timeLabel}`;
                                                }
                                            }
                                            return 'Time: Unknown';
                                        } catch (error) {
                                            console.error('Tooltip title error:', error);
                                            return 'Time: Error';
                                        }
                                    },
                                    label: function(context) {
                                        try {
                                            if (context && typeof context === 'object') {
                                                if (context && typeof context.dataIndex === 'number') {
                                                    const index = context.dataIndex;
                                                    
                                                    if (window.currentCandlestickData && 
                                                        window.currentCandlestickData.openData && 
                                                        window.currentCandlestickData.highData && 
                                                        window.currentCandlestickData.lowData && 
                                                        window.currentCandlestickData.closeData) {
                                                        
                                                        const data = [
                                                            `Open: ₹${window.currentCandlestickData.openData[index].toFixed(2)}`,
                                                            `High: ₹${window.currentCandlestickData.highData[index].toFixed(2)}`,
                                                            `Low: ₹${window.currentCandlestickData.lowData[index].toFixed(2)}`,
                                                            `Close: ₹${window.currentCandlestickData.closeData[index].toFixed(2)}`
                                                        ];
                                                        return data;
                                                    }
                                                }
                                            }
                                            return ['No data available'];
                                        } catch (error) {
                                            console.error('Tooltip label error:', error);
                                            return ['Error loading data'];
                                        }
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Time',
                                    color: '#cccccc',
                                    font: { size: 14, weight: 'bold' }
                                },
                                ticks: {
                                    color: '#cccccc',
                                    maxTicksLimit: 15,
                                    font: { size: 11 }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)',
                                    lineWidth: 0.5
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Price (₹)',
                                    color: '#cccccc',
                                    font: { size: 14, weight: 'bold' }
                                },
                                ticks: {
                                    color: '#cccccc',
                                    font: { size: 11 },
                                    callback: function(value) {
                                        return '₹' + value.toFixed(0);
                                    }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)',
                                    lineWidth: 0.5
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });

                console.log('Fallback Chart.js candlestick chart created successfully');
            }


            function getChartOptions(title, chartType) {
                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: title,
                            color: '#ffffff',
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            display: chartType === 'line',
                            labels: {
                                color: '#cccccc'
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#cccccc',
                                maxTicksLimit: 15 // Show more time labels for better readability
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#cccccc',
                                callback: function(value) {
                                    return '₹' + value.toFixed(2);
                                }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                };
            }

            async function switchChartType(chartType) {
                console.log('=== SWITCHING CHART TYPE ===');
                console.log('Requested chart type:', chartType);
                console.log('Current chart data available:', !!currentChartData);
                console.log('Current chart title available:', !!currentChartTitle);
                console.log('Current chart data sample:', currentChartData ? currentChartData.slice(0, 3) : 'none');
                
                if (!currentChartData || !currentChartTitle) {
                    console.error('No chart data available for switching');
                    alert('No chart data available for switching. Please generate a chart first.');
                    return;
                }
                
                // Update button states
                const lineBtn = document.getElementById('lineChartBtn');
                const candlestickBtn = document.getElementById('candlestickChartBtn');
                
                console.log('Updating button states...');
                lineBtn.classList.toggle('active', chartType === 'line');
                candlestickBtn.classList.toggle('active', chartType === 'candlestick');
                
                console.log('Line button active:', lineBtn.classList.contains('active'));
                console.log('Candlestick button active:', candlestickBtn.classList.contains('active'));
                
                // Recreate chart with new type
                console.log('=== CALLING CREATE INTERACTIVE CHART ===');
                console.log('With chart type:', chartType);
                await createInteractiveChart(currentChartData, currentChartTitle, chartType);
                console.log('Chart type switch completed');
            }

            function showError(message) {
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
                setTimeout(() => {
                    errorMessage.style.display = 'none';
                }, 5000);
            }

            function showSuccess(message) {
                successMessage.textContent = message;
                successMessage.style.display = 'block';
                setTimeout(() => {
                    successMessage.style.display = 'none';
                }, 3000);
            }

            function hideMessages() {
                errorMessage.style.display = 'none';
                successMessage.style.display = 'none';
            }

            function updateTimeframeDisplay() {
                const timeframe = document.getElementById('timeframe').value;
                const timeframeInfo = document.getElementById('timeframeInfo');
                const timeframeDisplay = document.getElementById('timeframeDisplay');
                const selectedTimeframe = document.getElementById('selectedTimeframe');
                
                // Update the help text based on timeframe
                if (timeframe === '1') {
                    timeframeInfo.textContent = 'Real-time 1-minute candlesticks for detailed analysis';
                    timeframeInfo.style.color = '#00ff88';
                } else if (timeframe <= '5') {
                    timeframeInfo.textContent = `${timeframe}-minute candlesticks for short-term trading`;
                    timeframeInfo.style.color = '#00ccff';
                } else if (timeframe <= '10') {
                    timeframeInfo.textContent = `${timeframe}-minute candlesticks for medium-term analysis`;
                    timeframeInfo.style.color = '#ff8800';
                } else {
                    timeframeInfo.textContent = `${timeframe}-minute candlesticks for swing trading`;
                    timeframeInfo.style.color = '#ff4444';
                }
                
                // Update the timeframe display
                selectedTimeframe.textContent = timeframe;
                timeframeDisplay.style.display = 'block';
            }

            // Add click event listeners for chart type buttons
            document.getElementById('lineChartBtn').addEventListener('click', function() {
                console.log('Line chart button clicked');
                switchChartType('line');
            });
            
            document.getElementById('candlestickChartBtn').addEventListener('click', function() {
                console.log('Candlestick chart button clicked');
                switchChartType('candlestick');
            });
            
            // Add event listener for timeframe input
            document.getElementById('timeframe').addEventListener('change', function() {
                updateTimeframeDisplay();
            });

            // Initialize page
            updateTimeframeDisplay();
            
            // Add event listeners for date dropdowns
            addDateEventListeners();
        });

        // Icon-based indicator selection functions
        let selectedIndicators = new Set();

        function toggleIndicatorMenu() {
            const dropdown = document.getElementById('indicatorDropdown');
            const isVisible = dropdown.style.display === 'block';
            
            if (isVisible) {
                dropdown.style.display = 'none';
                document.removeEventListener('click', closeIndicatorMenuOnOutsideClick);
            } else {
                dropdown.style.display = 'block';
                
                // Close menu when clicking outside
                document.addEventListener('click', closeIndicatorMenuOnOutsideClick);
            }
        }

        function closeIndicatorMenuOnOutsideClick(event) {
            const container = document.querySelector('.indicator-icon-container');
            if (!container.contains(event.target)) {
                document.getElementById('indicatorDropdown').style.display = 'none';
                document.removeEventListener('click', closeIndicatorMenuOnOutsideClick);
            }
        }

        function toggleIndicator(indicator) {
            const checkElement = document.getElementById(`check_${indicator}`);
            const emaSubmenu = document.getElementById('emaSubmenu');
            
            if (selectedIndicators.has(indicator)) {
                selectedIndicators.delete(indicator);
                checkElement.textContent = '☐';
                
                // If EMA is unchecked, hide submenu and uncheck all EMA options
                if (indicator === 'ema') {
                    emaSubmenu.style.display = 'none';
                    ['ema_20', 'ema_50', 'ema_100', 'ema_200'].forEach(ema => {
                        selectedIndicators.delete(ema);
                        const emaCheck = document.getElementById(`check_${ema}`);
                        if (emaCheck) emaCheck.textContent = '☐';
                    });
                }
            } else {
                selectedIndicators.add(indicator);
                checkElement.textContent = '☑';
                
                // If EMA is checked, show submenu
                if (indicator === 'ema') {
                    emaSubmenu.style.display = 'block';
                }
            }
            
            updateIndicatorCount();
        }

        function toggleEMAOption(emaOption) {
            const checkElement = document.getElementById(`check_${emaOption}`);
            
            if (selectedIndicators.has(emaOption)) {
                selectedIndicators.delete(emaOption);
                checkElement.textContent = '☐';
            } else {
                selectedIndicators.add(emaOption);
                checkElement.textContent = '☑';
            }
            
            updateIndicatorCount();
        }

        function updateIndicatorCount() {
            const count = selectedIndicators.size;
            const countElement = document.getElementById('indicatorCount');
            countElement.textContent = count;
            countElement.style.display = count > 0 ? 'flex' : 'none';
        }

        function getSelectedIndicators() {
            console.log('DEBUG: getSelectedIndicators called');
            console.log('DEBUG: selectedIndicators Set:', selectedIndicators);
            const result = Array.from(selectedIndicators);
            console.log('DEBUG: returning indicators array:', result);
            return result;
        }
    </script>
</body>
</html>

