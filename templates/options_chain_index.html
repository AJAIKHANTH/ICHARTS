<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Options Chain - Trading Analysis Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            width: 95vw;
            margin: 0 auto;
            background: rgba(26, 26, 46, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .header-top {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 10px;
        }

        .back-btn {
            position: absolute;
            left: 0;
            padding: 10px 20px;
            background: linear-gradient(45deg, #00ccff, #0099cc);
            border: none;
            border-radius: 25px;
            color: #ffffff;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0, 204, 255, 0.3);
        }

        .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 204, 255, 0.4);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .date-range-info {
            background: linear-gradient(90deg, #00ff88, #00ccff);
            color: #1a1a2e;
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 0.95rem;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }

        .date-range-info span {
            display: inline-flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .date-info-item {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: rgba(26, 26, 46, 0.2);
            border-radius: 15px;
            font-size: 0.9rem;
        }

        .date-selector-container {
            width: 100%;
        }

        .date-dropdowns {
            display: flex;
            gap: 8px;
            width: 100%;
        }

        .date-dropdown {
            padding: 10px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #ffffff;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 65px;
            max-width: 110px;
        }

        .date-dropdown:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .date-dropdown option {
            background: #1a1a2e;
            color: #ffffff;
        }

        .date-dropdown option.weekend {
            background: #2a1a1a;
            color: #ff8888;
        }


        .debug-info {
            font-size: 0.8rem;
            color: #cccccc;
            margin-top: 5px;
            padding: 5px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border-left: 2px solid #00ccff;
        }

        .controls-section {
            display: grid;
            grid-template-columns: 1fr 1.5fr 1fr 1fr;
            gap: 12px;
            margin-bottom: 15px;
            padding: 12px 18px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            align-items: start;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            color: #00ff88;
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group select,
        .control-group input {
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #ffffff;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .control-group select option {
            background: #1a1a2e;
            color: #ffffff;
        }

        .btn {
            padding: 10px 20px;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #1a1a2e;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            align-self: end;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.4);
        }

        .toggle-buttons-section {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .toggle-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .toggle-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: #cccccc;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .toggle-btn[data-active="true"] {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #1a1a2e;
            border-color: #00ff88;
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }

        .toggle-btn[data-active="true"]:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 255, 136, 0.4);
        }

        .btn-icon {
            font-size: 1.1rem;
        }

        .options-chain-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
        }


        .chain-header {
            display: grid;
            grid-template-columns: 1fr 120px 1fr;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }

        .call-header,
        .put-header {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            font-weight: 700;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .call-header {
            background: linear-gradient(45deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 136, 0.1));
            color: #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .put-header {
            background: linear-gradient(45deg, rgba(255, 136, 0, 0.2), rgba(255, 136, 0, 0.1));
            color: #ff8800;
            border: 1px solid rgba(255, 136, 0, 0.3);
        }

        .strike-header {
            text-align: center;
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            padding: 15px;
            border-radius: 10px;
            font-weight: 700;
            font-size: 1.1rem;
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .options-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            table-layout: fixed;
        }

        .options-table th {
            padding: 12px 4px;
            background: rgba(255, 255, 255, 0.1);
            color: #cccccc;
            font-weight: 600;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
        }

        /* Flexible column widths using percentages */
        .options-table th.greeks-column,
        .options-table td.greeks-column {
            width: 4.5%;
            min-width: 55px;
        }

        .options-table th.iv-column,
        .options-table td.iv-column {
            width: 5%;
            min-width: 60px;
        }

        .options-table th.volume-column,
        .options-table td.volume-column {
            width: 6%;
            min-width: 70px;
        }

        .options-table th.price-column,
        .options-table td.price-column {
            width: 7%;
            min-width: 80px;
        }

        .options-table th.strike-column,
        .options-table td.strike-price {
            width: 8%;
            min-width: 90px;
            font-weight: 700;
        }

        .call-columns {
            background: linear-gradient(90deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
        }

        .put-columns {
            background: linear-gradient(90deg, rgba(255, 136, 0, 0.05), rgba(255, 136, 0, 0.1));
        }

        .strike-column {
            background: rgba(255, 255, 255, 0.08);
            font-weight: 700;
            color: #ffffff;
        }

        .options-table td {
            padding: 8px 4px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.85rem;
            transition: background-color 0.2s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .options-table tr:hover td {
            background: rgba(255, 255, 255, 0.05);
        }

        .atm-row {
            background: rgba(255, 215, 0, 0.1) !important;
            border-top: 2px solid rgba(255, 215, 0, 0.3);
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }

        .atm-row td {
            background: rgba(255, 215, 0, 0.1) !important;
            font-weight: 600;
        }

        .atm-row .strike-price {
            background: rgba(255, 215, 0, 0.2) !important;
            color: #FFD700;
            font-weight: 700;
            font-size: 1rem;
        }

        .strike-price {
            font-weight: 700;
            font-size: 1rem;
            color: #ffffff;
            background: rgba(255, 255, 255, 0.1);
        }

        .ltp {
            font-weight: 600;
            color: #00ccff;
        }

        .volume {
            color: #cccccc;
        }

        .change-positive {
            color: #00ff88;
            font-weight: 600;
        }

        .change-negative {
            color: #ff4444;
            font-weight: 600;
        }

        .change-neutral {
            color: #cccccc;
        }

        /* Column visibility classes */
        .greeks-column {
            display: none;
        }

        .iv-column {
            display: none;
        }

        .volume-column {
            display: none;
        }

        .price-column {
            display: table-cell;
        }

        /* When columns are active */
        .show-greeks .greeks-column {
            display: table-cell;
        }

        .show-iv .iv-column {
            display: table-cell;
        }

        .show-volume .volume-column {
            display: table-cell;
        }

        .hide-price .price-column {
            display: none;
        }

        /* Greeks specific styling */
        .greek-value {
            font-size: 0.85rem;
            color: #00ccff;
        }

        .iv-value {
            font-size: 0.85rem;
            color: #ff8800;
            font-weight: 600;
        }

        .volume-detailed {
            font-size: 0.85rem;
            color: #cccccc;
        }

        /* Volume highlighting classes */
        .volume-highlight-call {
            background-color: rgba(0, 204, 255, 0.3) !important;
            border: 2px solid rgba(0, 204, 255, 0.6) !important;
            font-weight: 700 !important;
            color: #ffffff !important;
        }

        .volume-highlight-put {
            background-color: rgba(255, 215, 0, 0.3) !important;
            border: 2px solid rgba(255, 215, 0, 0.6) !important;
            font-weight: 700 !important;
            color: #ffffff !important;
        }

        .no-data {
            color: #666666;
            font-style: italic;
            font-size: 0.8rem;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #cccccc;
            font-size: 1.1rem;
        }

        .error {
            text-align: center;
            padding: 30px;
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid rgba(255, 68, 68, 0.3);
            border-radius: 10px;
            margin: 20px 0;
        }

        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #00ff88;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #cccccc;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @media (max-width: 1200px) {
            .container {
                max-width: 95vw;
                width: 95vw;
                padding: 15px;
                margin: 10px auto;
            }
            
            .controls-section {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .date-selector-container {
                flex-wrap: wrap;
                gap: 15px;
            }
            
            .options-chain-container {
                overflow-x: auto;
                padding: 10px;
            }
            
            .options-table {
                min-width: 1200px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
                margin: 5px;
                width: 98vw;
            }
            
            .controls-section {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .toggle-buttons {
                gap: 8px;
                justify-content: center;
            }
            
            .toggle-btn {
                padding: 8px 12px;
                font-size: 0.75rem;
            }
            
            .options-table {
                font-size: 0.7rem;
                min-width: 1000px;
            }
            
            .options-table th,
            .options-table td {
                padding: 4px 2px;
                font-size: 0.65rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-top">
                <button class="back-btn" onclick="goBack()">← Back to Main</button>
                <h1>⛓️ Options Chain Analysis</h1>
            </div>
            <p>Real-time Options Chain with Strike Prices, Volume & Greeks</p>
        </div>

        <div class="date-range-info" id="dateRangeInfo" style="display: none;">
            <span id="dateRangeText">Available Date Range: Loading...</span>
        </div>

        <div class="controls-section">
            <div class="control-group">
                <label for="symbol">Symbol</label>
                <select id="symbol">
                    <option value="nifty">NIFTY</option>
                    <option value="banknifty">BANK NIFTY</option>
                    <option value="midcpnifty">MIDCAP NIFTY</option>
                    <option value="sensex">SENSEX</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Select Date</label>
                <div class="date-selector-container">
                    <div class="date-dropdowns">
                        <select id="year" class="date-dropdown">
                            <option value="">Year</option>
                        </select>
                        <select id="month" class="date-dropdown">
                            <option value="">Month</option>
                        </select>
                        <select id="day" class="date-dropdown">
                            <option value="">Day</option>
                        </select>
                    </div>
                </div>
                <div class="debug-info" id="debugInfo">
                    <span style="color: #00ccff;">Debug Year: -</span> | 
                    <span style="color: #00ccff;">Month: -</span> | 
                    <span style="color: #00ccff;">Day: -</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="expiry">Expiry Date</label>
                <select id="expiry">
                    <option value="">Select Date First</option>
                </select>
            </div>
            
            <div class="control-group">
                <button class="btn" onclick="loadOptionsChain()">Load Options Chain</button>
            </div>
        </div>

        <div class="toggle-buttons-section" id="toggleButtonsSection" style="display: none;">
            <div class="toggle-buttons">
                <button class="toggle-btn" id="greeksBtn" onclick="toggleColumns('greeks')">
                    <span class="btn-icon">📊</span>
                    GREEKS
                </button>
                <button class="toggle-btn" id="ivBtn" onclick="toggleColumns('iv')">
                    <span class="btn-icon">📈</span>
                    IV
                </button>
                <button class="toggle-btn" id="volumeBtn" onclick="toggleColumns('volume')">
                    <span class="btn-icon">📊</span>
                    VOLUME
                </button>
                <button class="toggle-btn" id="priceBtn" onclick="toggleColumns('price')" data-active="true">
                    <span class="btn-icon">💰</span>
                    PRICE
                </button>
            </div>
        </div>

        <div class="options-chain-container" id="optionsChainContainer">
            <div class="loading">
                Select symbol, date, and expiry to load options chain data
            </div>
        </div>

        <div class="stats-section" id="statsSection" style="display: none;">
            <div class="stat-card">
                <div class="stat-value" id="totalStrikes">-</div>
                <div class="stat-label">Total Strikes</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="callVolume">-</div>
                <div class="stat-label">Call Volume</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="putVolume">-</div>
                <div class="stat-label">Put Volume</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="maxPain">-</div>
                <div class="stat-label">Max Pain</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables for date management
        let availableDates = [];
        let currentSymbol = 'nifty';

        // Load available dates when symbol changes
        document.getElementById('symbol').addEventListener('change', function() {
            currentSymbol = this.value;
            loadAvailableDates();
        });

        // Add event listeners for date dropdowns
        document.getElementById('year').addEventListener('change', function() {
            // Clear dependent dropdowns
            document.getElementById('month').value = '';
            document.getElementById('day').value = '';
            
            // Populate months for selected year
            if (this.value) {
                populateMonthDropdown(this.value);
            }
            
            updateDebugInfo();
        });
        
        document.getElementById('month').addEventListener('change', function() {
            // Clear day selection when month changes
            document.getElementById('day').value = '';
            
            // Populate days for selected month
            const year = document.getElementById('year').value;
            if (year && this.value) {
                populateDayDropdown(year, this.value);
            }
            
            updateDebugInfo();
        });
        
        document.getElementById('day').addEventListener('change', function() {
            console.log('Day changed to:', this.value);
            updateDebugInfo();
            loadAvailableExpiries();
        });

        function loadAvailableDates() {
            const symbol = currentSymbol;
            
            // Show loading in date range info
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            dateRangeInfo.style.display = 'block';
            document.getElementById('dateRangeText').textContent = 'Loading available dates...';
            
            // Clear date dropdowns
            clearDateDropdowns();
            
            // Clear expiry and options chain
            document.getElementById('expiry').innerHTML = '<option value="">Select Date First</option>';
            const container = document.getElementById('optionsChainContainer');
            container.innerHTML = '<div class="loading">Select symbol, date, and expiry to load options chain data</div>';
            
            // Hide toggle buttons and stats
            document.getElementById('toggleButtonsSection').style.display = 'none';
            document.getElementById('statsSection').style.display = 'none';
            
            // Fetch available dates from the server
            fetch(`/get_available_dates?data_type=${symbol}_call&symbol=${symbol}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.dates) {
                        availableDates = data.dates;
                        populateYearDropdown();
                        updateDateRangeInfo();
                    } else {
                        availableDates = [];
                        updateDateRangeInfo();
                    }
                })
                .catch(error => {
                    console.error('Error loading dates:', error);
                    availableDates = [];
                    updateDateRangeInfo();
                });
        }

        function clearDateDropdowns() {
            document.getElementById('year').innerHTML = '<option value="">Year</option>';
            document.getElementById('month').innerHTML = '<option value="">Month</option>';
            document.getElementById('day').innerHTML = '<option value="">Day</option>';
            updateDebugInfo();
        }

        function populateYearDropdown() {
            const yearSelect = document.getElementById('year');
            yearSelect.innerHTML = '<option value="">Year</option>';
            
            const years = [...new Set(availableDates.map(date => date.substring(0, 4)))].sort();
            years.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearSelect.appendChild(option);
            });
        }

        function updateAvailableDays() {
            const year = document.getElementById('year').value;
            const month = document.getElementById('month').value;
            
            console.log('updateAvailableDays called with year:', year, 'month:', month);
            console.log('Available dates length:', availableDates.length);
            
            updateDebugInfo();
            
            if (!year) {
                console.log('No year selected, clearing month and day');
                document.getElementById('month').innerHTML = '<option value="">Month</option>';
                document.getElementById('day').innerHTML = '<option value="">Day</option>';
                return;
            }
            
            // Always populate months when year is selected
            console.log('Populating months for year:', year);
            populateMonthDropdown(year);
            
            if (!month) {
                console.log('Year selected but no month, clearing day only');
                document.getElementById('day').innerHTML = '<option value="">Day</option>';
                return;
            }
            
            console.log('Both year and month selected, populating days');
            populateDayDropdown(year, month);
        }

        function populateMonthDropdown(year) {
            const monthSelect = document.getElementById('month');
            monthSelect.innerHTML = '<option value="">Month</option>';
            
            // Populate all 12 months (same as straddle chart)
            for (let month = 1; month <= 12; month++) {
                const option = document.createElement('option');
                option.value = month.toString().padStart(2, '0');
                option.textContent = new Date(year, month - 1, 1).toLocaleDateString('en-US', { month: 'long' });
                monthSelect.appendChild(option);
            }
        }

        function populateDayDropdown(year, month) {
            const daySelect = document.getElementById('day');
            daySelect.innerHTML = '<option value="">Day</option>';
            
            // Get all days in the month first
            const daysInMonth = new Date(year, parseInt(month), 0).getDate();
            
            // Filter to only show available days from database
            const availableDays = availableDates
                .filter(date => date.startsWith(`${year}-${month}`))
                .map(date => date.substring(8, 10))
                .sort((a, b) => parseInt(a) - parseInt(b));
            
            // Create options for all days in month, but only enable available ones
            for (let day = 1; day <= daysInMonth; day++) {
                const dayStr = day.toString().padStart(2, '0');
                const option = document.createElement('option');
                option.value = dayStr;
                
                // Check if this day is available in our database
                const isAvailable = availableDays.includes(dayStr);
                
                // Check if it's a weekend
                const dateObj = new Date(year, parseInt(month) - 1, day);
                const dayOfWeek = dateObj.getDay(); // 0 = Sunday, 6 = Saturday
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                
                if (isWeekend) {
                    option.textContent = `${day} (Weekend)`;
                    option.className = 'weekend';
                    option.disabled = !isAvailable; // Disable if not available
                    option.style.color = '#ff8888';
                    option.style.fontStyle = 'italic';
                } else {
                    option.textContent = day;
                    option.disabled = !isAvailable; // Disable if not available
                    if (!isAvailable) {
                        option.style.color = '#666';
                        option.style.fontStyle = 'italic';
                    }
                }
                
                daySelect.appendChild(option);
            }
        }

        function updateDebugInfo() {
            const year = document.getElementById('year').value || '-';
            const month = document.getElementById('month').value || '-';
            const day = document.getElementById('day').value || '-';
            
            document.getElementById('debugInfo').innerHTML = 
                `<span style="color: #00ccff;">Debug Year: ${year}</span> | ` +
                `<span style="color: #00ccff;">Month: ${month}</span> | ` +
                `<span style="color: #00ccff;">Day: ${day}</span>`;
        }

        function updateDateRangeInfo() {
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            const dateRangeText = document.getElementById('dateRangeText');
            
            if (availableDates.length === 0) {
                dateRangeText.innerHTML = 'No data available for selected symbol';
                return;
            }
            
            const sortedDates = [...availableDates].sort();
            const actualMinDate = sortedDates[0];
            const actualMaxDate = sortedDates[sortedDates.length - 1];
            const actualTradingDays = availableDates.length;
            
            // Calculate total calendar days between min and max dates
            const minDateObj = new Date(actualMinDate);
            const maxDateObj = new Date(actualMaxDate);
            const timeDiff = maxDateObj.getTime() - minDateObj.getTime();
            const totalCalendarDays = Math.ceil(timeDiff / (1000 * 3600 * 24)) + 1;
            
            // Calculate weekends in the date range
            let actualWeekends = 0;
            const currentDate = new Date(minDateObj);
            while (currentDate <= maxDateObj) {
                const dayOfWeek = currentDate.getDay();
                if (dayOfWeek === 0 || dayOfWeek === 6) { // Sunday = 0, Saturday = 6
                    actualWeekends++;
                }
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            // Calculate holidays (total calendar days - actual trading days - weekends)
            const holidays = Math.max(0, totalCalendarDays - actualTradingDays - actualWeekends);
            
            // Update date range info with exact format from straddle chart
            dateRangeText.innerHTML = `
                <strong>Available Date Range:</strong> ${actualMinDate} to ${actualMaxDate} | 📅 <strong>Total Days:</strong> ${totalCalendarDays} | 📊 <strong>Trading Days:</strong> ${actualTradingDays} | 🏖️ <strong>Weekends:</strong> ${actualWeekends} | 🏛️ <strong>Holidays:</strong> ${holidays}
            `;
        }


        function getCurrentSelectedDate() {
            const year = document.getElementById('year').value;
            const month = document.getElementById('month').value;
            const day = document.getElementById('day').value;
            
            if (!year || !month || !day) return null;
            return `${year}-${month}-${day}`;
        }

        function loadAvailableExpiries() {
            const symbol = document.getElementById('symbol').value;
            const selectedDate = getCurrentSelectedDate();
            
            const expirySelect = document.getElementById('expiry');
            
            if (!selectedDate) {
                expirySelect.innerHTML = '<option value="">Select Date First</option>';
                return;
            }
            
            expirySelect.innerHTML = '<option value="">Loading expiries...</option>';
            
            fetch(`/get_options_expiries?date=${selectedDate}&symbol=${symbol}`)
                .then(response => response.json())
                .then(data => {
                    expirySelect.innerHTML = '<option value="">Select Expiry</option>';
                    
                    if (data.success && data.expiries) {
                        data.expiries.forEach(expiry => {
                            const option = document.createElement('option');
                            option.value = expiry.value;
                            option.textContent = expiry.display;
                            expirySelect.appendChild(option);
                        });
                        
                        // Don't auto-select any expiry - let user choose
                    }
                })
                .catch(error => {
                    console.error('Error loading expiries:', error);
                    expirySelect.innerHTML = '<option value="">Error loading expiries</option>';
                });
        }

        function loadOptionsChain() {
            const symbol = document.getElementById('symbol').value;
            const selectedDate = getCurrentSelectedDate();
            const expiry = document.getElementById('expiry').value;
            
            if (!selectedDate) {
                alert('Please select a trading date');
                return;
            }
            
            const container = document.getElementById('optionsChainContainer');
            container.innerHTML = '<div class="loading">Loading options chain data...</div>';
            
            const url = `/get_options_chain_data?date=${selectedDate}&symbol=${symbol}` + (expiry ? `&expiry=${expiry}` : '');
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log('=== OPTIONS CHAIN DATA DEBUG ===');
                        console.log('Total strikes received:', data.total_strikes);
                        console.log('Underlying price received:', data.underlying_price);
                        console.log('Options chain data:', data.options_chain);
                        
                        // Debug call vs put data
                        let callsWithData = 0;
                        let putsWithData = 0;
                        
                        data.options_chain.forEach(row => {
                            if (row.call.ltp > 0 || row.call.volume > 0) callsWithData++;
                            if (row.put.ltp > 0 || row.put.volume > 0) putsWithData++;
                        });
                        
                        console.log(`Calls with data: ${callsWithData} out of ${data.total_strikes}`);
                        console.log(`Puts with data: ${putsWithData} out of ${data.total_strikes}`);
                        
                        displayOptionsChain(data.options_chain, data.underlying_price);
                        updateStats(data);
                    } else {
                        container.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                    }
                })
                .catch(error => {
                    console.error('Error loading options chain:', error);
                    container.innerHTML = '<div class="error">Failed to load options chain data</div>';
                });
        }

        function displayOptionsChain(optionsChain, underlyingPrice) {
            const container = document.getElementById('optionsChainContainer');
            
            // Find ATM strike (strike closest to underlying price)
            let atmStrike = null;
            let minDistance = Infinity;
            
            // Find highest volume in calls and puts for highlighting
            let maxCallVolume = 0;
            let maxPutVolume = 0;
            
            // Calculate ATM strike based on underlying price
            if (underlyingPrice && underlyingPrice > 0) {
                optionsChain.forEach(row => {
                    const distance = Math.abs(row.strike - underlyingPrice);
                    if (distance < minDistance) {
                        minDistance = distance;
                        atmStrike = row.strike;
                    }
                });
            } else {
                // Fallback: Use strike with highest combined volume if no underlying price
                console.log('No underlying price available, using volume-based ATM calculation as fallback');
                let maxCombinedVolume = 0;
                optionsChain.forEach(row => {
                    const combinedVolume = (row.call.volume || 0) + (row.put.volume || 0);
                    if (combinedVolume > maxCombinedVolume) {
                        maxCombinedVolume = combinedVolume;
                        atmStrike = row.strike;
                    }
                });
            }
            
            // Also track highest volumes for highlighting
            optionsChain.forEach(row => {
                if (row.call.volume > maxCallVolume) {
                    maxCallVolume = row.call.volume;
                }
                if (row.put.volume > maxPutVolume) {
                    maxPutVolume = row.put.volume;
                }
            });
            
            console.log('Underlying Price:', underlyingPrice);
            console.log('ATM Strike detected:', atmStrike, 'distance from underlying:', minDistance);
            console.log('Max Call Volume:', maxCallVolume, 'Max Put Volume:', maxPutVolume);
            
            let html = `
                <div class="chain-header">
                    <div class="call-header">CALL OPTIONS</div>
                    <div class="strike-header">
                        STRIKE
                        ${underlyingPrice ? `<br><small style="color: #FFD700; font-size: 0.8em;">Spot: ${underlyingPrice.toFixed(2)}</small>` : ''}
                    </div>
                    <div class="put-header">PUT OPTIONS</div>
                </div>
                
                <table class="options-table" id="optionsTable">
                    <thead>
                        <tr>
                            <!-- Call side columns -->
                            <th class="call-columns greeks-column">Vega</th>
                            <th class="call-columns greeks-column">Theta</th>
                            <th class="call-columns greeks-column">Gamma</th>
                            <th class="call-columns greeks-column">Delta</th>
                            <th class="call-columns iv-column">IV</th>
                            <th class="call-columns volume-column">Volume</th>
                            <th class="call-columns price-column">LTP</th>
                            <th class="call-columns price-column">Change</th>
                            <th class="call-columns price-column">Change %</th>
                            
                            <!-- Strike column -->
                            <th class="strike-column">Strike</th>
                            
                            <!-- Put side columns -->
                            <th class="put-columns price-column">Change %</th>
                            <th class="put-columns price-column">Change</th>
                            <th class="put-columns price-column">LTP</th>
                            <th class="put-columns volume-column">Volume</th>
                            <th class="put-columns iv-column">IV</th>
                            <th class="put-columns greeks-column">Delta</th>
                            <th class="put-columns greeks-column">Gamma</th>
                            <th class="put-columns greeks-column">Theta</th>
                            <th class="put-columns greeks-column">Vega</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            optionsChain.forEach(row => {
                const callChange = row.call.change || 0;
                const putChange = row.put.change || 0;
                const callChangePercent = row.call.change_percent || 0;
                const putChangePercent = row.put.change_percent || 0;
                
                const callChangeClass = callChange > 0 ? 'change-positive' : (callChange < 0 ? 'change-negative' : 'change-neutral');
                const putChangeClass = putChange > 0 ? 'change-positive' : (putChange < 0 ? 'change-negative' : 'change-neutral');
                
                // Only generate Greeks and IV data if actual trading data exists
                const hasCallData = row.call.ltp > 0 || row.call.volume > 0;
                const hasPutData = row.put.ltp > 0 || row.put.volume > 0;
                
                // Calculate real Greeks using Black-Scholes model
                const actualUnderlyingPrice = (underlyingPrice && underlyingPrice > 0) ? underlyingPrice : 25000; // Use actual underlying price from database
                const selectedExpiry = document.getElementById('expiry').value; // Get selected expiry
                const timeToExpiry = calculateTimeToExpiry(selectedExpiry); // Days to expiry
                
                const callGreeks = hasCallData ? calculateRealGreeks(
                    row.strike, 'call', actualUnderlyingPrice, row.call.ltp, timeToExpiry
                ) : null;
                const putGreeks = hasPutData ? calculateRealGreeks(
                    row.strike, 'put', actualUnderlyingPrice, row.put.ltp, timeToExpiry
                ) : null;
                
                // Check if this is the ATM strike
                const isATM = row.strike === atmStrike;
                const rowClass = isATM ? 'atm-row' : '';
                
                // Check if this row has the highest volume for highlighting
                const isMaxCallVolume = row.call.volume === maxCallVolume && row.call.volume > 0;
                const isMaxPutVolume = row.put.volume === maxPutVolume && row.put.volume > 0;
                
                // Apply volume highlighting classes
                const callVolumeClass = isMaxCallVolume ? 'volume-highlight-call' : '';
                const putVolumeClass = isMaxPutVolume ? 'volume-highlight-put' : '';
                
                html += `
                    <tr class="${rowClass}">
                        <!-- Call side -->
                        <td class="greeks-column greek-value">${callGreeks ? callGreeks.vega : '<span class="no-data">N/A</span>'}</td>
                        <td class="greeks-column greek-value">${callGreeks ? callGreeks.theta : '<span class="no-data">N/A</span>'}</td>
                        <td class="greeks-column greek-value">${callGreeks ? callGreeks.gamma : '<span class="no-data">N/A</span>'}</td>
                        <td class="greeks-column greek-value">${callGreeks ? callGreeks.delta : '<span class="no-data">N/A</span>'}</td>
                        <td class="iv-column iv-value">${callGreeks ? callGreeks.iv + '%' : '<span class="no-data">N/A</span>'}</td>
                        <td class="volume-column volume-detailed ${callVolumeClass}">${row.call.volume > 0 ? formatVolume(row.call.volume) : '<span class="no-data">N/A</span>'}</td>
                        <td class="price-column ltp">${row.call.ltp > 0 ? row.call.ltp.toFixed(2) : '<span class="no-data">N/A</span>'}</td>
                        <td class="price-column ${callChangeClass}">${hasCallData ? (callChange > 0 ? '+' : '') + callChange.toFixed(2) : '<span class="no-data">N/A</span>'}</td>
                        <td class="price-column ${callChangeClass}">${hasCallData ? (callChangePercent > 0 ? '+' : '') + callChangePercent.toFixed(2) + '%' : '<span class="no-data">N/A</span>'}</td>
                        
                        <!-- Strike -->
                        <td class="strike-price">${row.strike}</td>
                        
                        <!-- Put side -->
                        <td class="price-column ${putChangeClass}">${hasPutData ? (putChangePercent > 0 ? '+' : '') + putChangePercent.toFixed(2) + '%' : '<span class="no-data">N/A</span>'}</td>
                        <td class="price-column ${putChangeClass}">${hasPutData ? (putChange > 0 ? '+' : '') + putChange.toFixed(2) : '<span class="no-data">N/A</span>'}</td>
                        <td class="price-column ltp">${row.put.ltp > 0 ? row.put.ltp.toFixed(2) : '<span class="no-data">N/A</span>'}</td>
                        <td class="volume-column volume-detailed ${putVolumeClass}">${row.put.volume > 0 ? formatVolume(row.put.volume) : '<span class="no-data">N/A</span>'}</td>
                        <td class="iv-column iv-value">${putGreeks ? putGreeks.iv + '%' : '<span class="no-data">N/A</span>'}</td>
                        <td class="greeks-column greek-value">${putGreeks ? putGreeks.delta : '<span class="no-data">N/A</span>'}</td>
                        <td class="greeks-column greek-value">${putGreeks ? putGreeks.gamma : '<span class="no-data">N/A</span>'}</td>
                        <td class="greeks-column greek-value">${putGreeks ? putGreeks.theta : '<span class="no-data">N/A</span>'}</td>
                        <td class="greeks-column greek-value">${putGreeks ? putGreeks.vega : '<span class="no-data">N/A</span>'}</td>
                    </tr>
                `;
            });
            
            html += `
                    </tbody>
                </table>
            `;
            
            container.innerHTML = html;
            
            // Apply current toggle states to the new table
            applyCurrentToggleStates();
        }

        function updateStats(data) {
            const statsSection = document.getElementById('statsSection');
            statsSection.style.display = 'grid';
            
            // Show toggle buttons section when data is loaded
            const toggleSection = document.getElementById('toggleButtonsSection');
            toggleSection.style.display = 'block';
            
            // Calculate statistics
            let totalCallVolume = 0;
            let totalPutVolume = 0;
            
            data.options_chain.forEach(row => {
                totalCallVolume += row.call.volume || 0;
                totalPutVolume += row.put.volume || 0;
            });
            
            // Calculate Max Pain
            const maxPainStrike = calculateMaxPain(data.options_chain);
            
            // Update stat cards
            document.getElementById('totalStrikes').textContent = data.total_strikes;
            document.getElementById('callVolume').textContent = totalCallVolume.toLocaleString();
            document.getElementById('putVolume').textContent = totalPutVolume.toLocaleString();
            document.getElementById('maxPain').textContent = maxPainStrike;
        }

        function calculateRealGreeks(strike, optionType, underlyingPrice, optionPrice, timeToExpiry, riskFreeRate = 0.05) {
            // Calculate real Greeks using Black-Scholes model
            const S = underlyingPrice; // Current underlying price
            const K = strike; // Strike price
            const T = timeToExpiry / 365; // Time to expiry in years
            const r = riskFreeRate; // Risk-free rate
            
            // Handle edge cases
            if (T <= 0 || optionPrice <= 0 || S <= 0 || K <= 0) {
                return {
                    delta: 0,
                    gamma: 0,
                    theta: 0,
                    vega: 0,
                    iv: 0
                };
            }
            
            const sigma = calculateImpliedVolatility(optionPrice, S, K, T, r, optionType); // IV
            
            if (sigma <= 0 || !isFinite(sigma)) {
                return {
                    delta: 0,
                    gamma: 0,
                    theta: 0,
                    vega: 0,
                    iv: 0
                };
            }
            
            const d1 = (Math.log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
            const d2 = d1 - sigma * Math.sqrt(T);
            
            // Standard normal distribution approximation
            const N = (x) => 0.5 * (1 + erf(x / Math.sqrt(2)));
            const n = (x) => Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
            
            let delta, gamma, theta, vega;
            
            if (optionType === 'call') {
                delta = N(d1);
                theta = (-S * n(d1) * sigma / (2 * Math.sqrt(T)) - r * K * Math.exp(-r * T) * N(d2)) / 365;
            } else {
                delta = N(d1) - 1;
                theta = (-S * n(d1) * sigma / (2 * Math.sqrt(T)) + r * K * Math.exp(-r * T) * N(-d2)) / 365;
            }
            
            gamma = n(d1) / (S * sigma * Math.sqrt(T));
            vega = S * n(d1) * Math.sqrt(T) / 100; // Per 1% change in volatility
            
            return {
                delta: delta.toFixed(4),
                gamma: gamma.toFixed(4),
                theta: theta.toFixed(2),
                vega: vega.toFixed(2),
                iv: (sigma * 100).toFixed(2)
            };
        }
        
        function calculateImpliedVolatility(optionPrice, S, K, T, r, optionType) {
            // Newton-Raphson method to find implied volatility
            let sigma = 0.2; // Initial guess
            const maxIterations = 100;
            const tolerance = 0.0001;
            
            // Handle edge cases
            if (T <= 0 || optionPrice <= 0 || S <= 0 || K <= 0) {
                return 0;
            }
            
            for (let i = 0; i < maxIterations; i++) {
                const d1 = (Math.log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
                const d2 = d1 - sigma * Math.sqrt(T);
                
                const N = (x) => 0.5 * (1 + erf(x / Math.sqrt(2)));
                const n = (x) => Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
                
                let theoreticalPrice;
                if (optionType === 'call') {
                    theoreticalPrice = S * N(d1) - K * Math.exp(-r * T) * N(d2);
                } else {
                    theoreticalPrice = K * Math.exp(-r * T) * N(-d2) - S * N(-d1);
                }
                
                const vega = S * n(d1) * Math.sqrt(T);
                const priceDiff = theoreticalPrice - optionPrice;
                
                if (Math.abs(priceDiff) < tolerance) break;
                
                // Avoid division by zero
                if (Math.abs(vega) < 1e-10) break;
                
                sigma = sigma - priceDiff / vega;
                if (sigma < 0) sigma = 0.01;
                if (sigma > 5) sigma = 5;
                
                // Check for convergence issues
                if (!isFinite(sigma)) {
                    sigma = 0.2; // Reset to initial guess
                    break;
                }
            }
            
            return Math.max(0, Math.min(5, sigma)); // Clamp between 0 and 5
        }
        
        function erf(x) {
            // Approximation of error function
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;
            
            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x);
            
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            
            return sign * y;
        }
        
        function calculateTimeToExpiry(expiryDate) {
            if (!expiryDate) return 7; // Default to 7 days if no expiry
            
            const today = new Date();
            const expiry = new Date(expiryDate);
            const diffTime = expiry - today;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            return Math.max(1, diffDays); // At least 1 day
        }

        function formatVolume(volume) {
            if (volume === 0) return '-';
            if (volume >= 1000000) return (volume / 1000000).toFixed(1) + 'M';
            if (volume >= 1000) return (volume / 1000).toFixed(1) + 'K';
            return volume.toString();
        }

        function calculateMaxPain(optionsChain) {
            console.log('=== MAX PAIN CALCULATION ===');
            
            if (!optionsChain || optionsChain.length === 0) {
                console.log('No options chain data for Max Pain calculation');
                return 'N/A';
            }
            
            let maxPainStrike = null;
            let maxPainValue = 0;
            
            // For each potential underlying price (each strike), calculate total pain
            optionsChain.forEach(underlyingStrike => {
                let totalPain = 0;
                const underlyingPrice = underlyingStrike.strike; // Fixed variable reference
                
                // Calculate pain for all call and put options at this underlying price
                optionsChain.forEach(optionRow => {
                    const strike = optionRow.strike;
                    const callVolume = optionRow.call.volume || 0;
                    const putVolume = optionRow.put.volume || 0;
                    const callLTP = optionRow.call.ltp || 0;
                    const putLTP = optionRow.put.ltp || 0;
                    
                    // Call options: pain when ITM (underlying > strike)
                    // Option writers lose money when calls are in-the-money
                    if (underlyingPrice > strike && callVolume > 0) {
                        const intrinsicValue = underlyingPrice - strike;
                        totalPain += callVolume * intrinsicValue;
                    }
                    
                    // Put options: pain when ITM (underlying < strike)  
                    // Option writers lose money when puts are in-the-money
                    if (underlyingPrice < strike && putVolume > 0) {
                        const intrinsicValue = strike - underlyingPrice;
                        totalPain += putVolume * intrinsicValue;
                    }
                });
                
                // Track the strike that causes maximum pain
                if (totalPain > maxPainValue) {
                    maxPainValue = totalPain;
                    maxPainStrike = underlyingStrike.strike;
                }
            });
            
            console.log('Max Pain Strike:', maxPainStrike, 'with total pain value:', maxPainValue);
            return maxPainStrike || 'N/A';
        }

        function toggleColumns(columnType) {
            const table = document.getElementById('optionsTable');
            const button = document.getElementById(columnType + 'Btn');
            
            if (!table) return;
            
            const isActive = button.getAttribute('data-active') === 'true';
            
            if (isActive) {
                // Deactivate
                button.setAttribute('data-active', 'false');
                table.classList.remove('show-' + columnType);
                if (columnType === 'price') {
                    table.classList.add('hide-price');
                }
            } else {
                // Activate
                button.setAttribute('data-active', 'true');
                table.classList.add('show-' + columnType);
                if (columnType === 'price') {
                    table.classList.remove('hide-price');
                }
            }
        }

        function applyCurrentToggleStates() {
            const table = document.getElementById('optionsTable');
            if (!table) return;
            
            // Get current button states
            const greeksBtn = document.getElementById('greeksBtn');
            const ivBtn = document.getElementById('ivBtn');
            const volumeBtn = document.getElementById('volumeBtn');
            const priceBtn = document.getElementById('priceBtn');
            
            // Apply states to table
            if (greeksBtn && greeksBtn.getAttribute('data-active') === 'true') {
                table.classList.add('show-greeks');
            } else {
                table.classList.remove('show-greeks');
            }
            
            if (ivBtn && ivBtn.getAttribute('data-active') === 'true') {
                table.classList.add('show-iv');
            } else {
                table.classList.remove('show-iv');
            }
            
            if (volumeBtn && volumeBtn.getAttribute('data-active') === 'true') {
                table.classList.add('show-volume');
            } else {
                table.classList.remove('show-volume');
            }
            
            if (priceBtn && priceBtn.getAttribute('data-active') === 'true') {
                table.classList.remove('hide-price');
            } else {
                table.classList.add('hide-price');
            }
        }

        function goBack() {
            window.location.href = '/';
        }

        // Initialize page and load available dates for default symbol
        document.addEventListener('DOMContentLoaded', function() {
            // Load available dates for the default symbol (NIFTY)
            currentSymbol = document.getElementById('symbol').value;
            loadAvailableDates();
        });
    </script>
</body>
</html>
